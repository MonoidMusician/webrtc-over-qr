<!DOCTYPE html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script class="stage1">// stage1 loads everything in the document's `<head>`, so that stage2 has access
// to all of the helper libraries and such when loading the body. it needs to
// be less than 16KB.
"use strict";
(function detectRole() {
  if (!window.role) {
    if ((window.rtc || window.R) instanceof RTCPeerConnection && (window.dc || window.D) instanceof RTCDataChannel) {
      window.role = 'guest';
    } else {
      window.role = 'host';
    }
  }
  if (!['host','guest'].includes(window.role)) {
    throw new Error('Could not determine role');
  }
})();
if (role === 'guest') {
  function assert(condition, message="Assertion failed") {
    if (!condition) throw new Error(message);
  }

  // Clean up the code golfed stage0, which ends up setting single-letter
  // global variables on `window`
  function cleanup() {
    const rtc = window.rtc || window.R;
    assert(rtc instanceof RTCPeerConnection);
    const dc = window.dc || window.D;
    assert(dc instanceof RTCDataChannel);
    for (const k in window) {
      if (k.length === 1 && isNaN(k)) {
        delete window[k];
      }
    }
    delete window.rtc;
    delete window.dc;
    delete window.cleanup;
    return { rtc, dc };
  };

  (async function stage1guest({ rtc, dc }) { try {
    const current = 'stage1';
    dc.send(JSON.stringify({ stage: current, type: 'ready' }));

    let pending = []; let idle = true;
    dc.onmessage = ev => {
      pending.push(ev);
      if (idle) {
        poke();
      }
    };

    function poke() {
      let ev = pending.shift();
      if (idle = !ev) return;
      let request = JSON.parse(ev.data);
      assert(request.stage === current);
      if (request.type === 'done') {
        dc.send(JSON.stringify({ stage: current, type: 'done' }));

        stage2({ rtc, dc });
        return;
      }
      assert(request.type === 'element');
      if (request.tag === 'script' && request.attrs.src) {
        let element = document.createElement(request.tag);
        element.src = request.attrs.src;
        element.onload = poke;
        document.head.appendChild(element);
      } else {
        let element = document.createElement(request.tag);
        for (let [name, value] of Object.entries(request.attrs)) {
          element.setAttribute(name, value);
        }
        element.textContent = request.textContent;
        document.head.appendChild(element);
        poke();
      }
    }
  } catch(e) {
    document.body.textContent = String(e);
    dc.send(JSON.stringify({ stage: current, type: 'error', message: e.message, stack: e.stack, e }));
    throw e;
  }})(cleanup());
} else if (role === 'host') {
  window.stage1 = async function stage1host({ rtc, dc }) { try {
    assert(dc instanceof RTCDataChannel);
    function isEphemeral(el) {
      return [...el.classList].some(cls => isEphemeral.classes.includes(cls));
    }
    isEphemeral.classes = ["ephemeral", "stage0", "stage1", "host-only"];
    const current = 'stage1';
    dc.onmessage = () => {};
    let initiated = false;
    async function initiate(stage1script) {
      // This is, ideally, our only use of the remote `eval()`, ... for whatever
      // it's worth
      dc.send(Ve.scripty`
        (async function() {
          try {
            for (let element of [...document.head.children]) {
              if (element.localName === 'style') document.head.removeChild(element);
            }
            document.head.appendChild(Object.assign(document.createElement('base'), {href:${document.baseURI}}));
            await new Promise((resolve,reject) => {
              const script = ${{
                src: stage1script.src || undefined,
                textContent: stage1script.textContent || undefined,
              }};
              document.head.appendChild(Object.assign(document.createElement('script'), {
                className: 'stage1',
                ...script,
                onerror: (ev) => reject(Object.assign(new Error("Failed to load stage1"), ev)),
                onload: resolve,
              }));
              if (!script.src) resolve();
            });
          } catch(e) {
            (window.dc || window.D).send(JSON.stringify({ stage: ${current}, type: 'error', message: e.message, stack: e.stack, e }));
            console.error(e);
            throw e;
          }
        })();
      `);
      var ev = JSON.parse((await Ve.once.message(dc)).data);
      assert(ev.stage === current);
      if (ev.type === 'error') {
        host_ui.throwError(Object.assign(new Error(ev.message), ev));
      }
    }
    for (let child of document.head.children) {
      if (!initiated) {
        if (child.tagName === 'SCRIPT' && child.classList.contains('stage1')) {
          await initiate(child);
          initiated = true;
        } else if (child.tagName === 'BASE') {
          if (!child.getAttribute('href')) child.setAttribute('href', document.baseURI);
        }
        continue;
      }
      if (isEphemeral(child)) continue;
      let tag = child.tagName.toLowerCase();
      let msg = { stage: current, type: 'element', tag };
      msg.attrs = Object.fromEntries(Array.from(child.attributes).map(attr=>[attr.name,attr.value]));
      msg.textContent = child.textContent;
      if (tag === 'script') {
        // if (!msg.attrs.src && msg.textContent) {
        //   // We have access to `toDataURI` here, as the host
        //   msg.attrs.src = toDataURI(msg.textContent, 'application/javascript');
        //   msg.textContent = '';
        // }
      }
      if (!Array.from(child.children).every(isEphemeral)) {
        console.warn('Ignoring children of element in head:', child);
      }
      dc.send(JSON.stringify(msg));
    }
    if (!initiated) throw new Error('Did not find stage1 script');
    dc.send(JSON.stringify({ stage: current, type: 'done' }));
    var ev = JSON.parse((await Ve.once.message(dc)).data);
    if (ev.type === 'error') {
      host_ui.throwError(Object.assign(new Error(ev.message), ev));
    }
    assert(ev.stage === current);
    assert(ev.type === 'done');
    var ev = JSON.parse((await Ve.once.message(dc)).data);
    if (ev.type === 'error') {
      host_ui.throwError(Object.assign(new Error(ev.message), ev));
    }
    assert(ev.stage === 'stage2');
    assert(ev.type === 'ready');
    stage2({ rtc, dc });
  } catch(e) {
    host_ui.throwError(e); throw e;
  }};
}
</script><title>QR Scanner</title><style>:root {
  font-family: sans-serif;
  word-break: break-word;
  /* adapted from https://github.com/holoviz/colorcet/blob/main/assets/CET/rainbow_bgyrm_35-85_c69_n256.csv */
  --rainbow: rgb(0,47,246), rgb(20,74,218), rgb(25,94,190), rgb(24,110,164), rgb(38,122,139), rgb(54,133,115), rgb(62,143,90), rgb(65,154,63), rgb(71,163,36), rgb(90,171,19), rgb(114,177,16), rgb(138,183,20), rgb(161,189,23), rgb(183,194,27), rgb(205,199,31), rgb(225,203,34), rgb(242,203,36), rgb(249,195,35), rgb(250,184,33), rgb(249,171,30), rgb(248,158,28), rgb(247,145,25), rgb(245,132,23), rgb(243,118,21), rgb(241,103,21), rgb(240,90,28), rgb(243,86,50), rgb(248,92,81), rgb(253,103,115), rgb(256,113,149), rgb(256,125,183), rgb(256,136,219);

  /* Chosen hue */
  --hue: 310;

  /* Interactive elements */
  --ui-focus: rgb(227, 12, 48);
  --ui-defocus: rgb(122, 31, 179);
  --ui-stark: black;
  --ui-semi: 0.4;
  --ui-half: rgba(0,0,0,var(--ui-semi));

  --bubble: lch(90 40 var(--hue));
  --bubble-half: lch(90 40 var(--hue) / 50%);
  @media (prefers-color-scheme: dark) {
    --link: rgb(137, 137, 255);
    --link-visited: rgb(212, 124, 209);
    --ui-focus: rgb(198, 68, 89);
    --ui-defocus: rgb(135, 91, 163);
    --ui-stark: white;
    --ui-semi: 0.6;
    --ui-half: rgba(255,255,255,var(--ui-semi));

    --bubble: lch(50 30 var(--hue) / 25%);
    --bubble-half: lch(50 30 var(--hue) / 15%);

    & a[href] {
      color: var(--link);
      &:visited {
        color: var(--link-visited);
      }
    }
  }
}
@media (prefers-color-scheme: dark) {
  :root, body {
    background: lch(4 13 var(--hue));
    color: #eee;
  }
}

body {
  margin: 0;
  padding: 0;
}

details > summary { cursor: pointer }
pre, code { text-align: left; font-size: 0.8rem }

body > #main {
  padding: 0.5rem;
  display: flex;
  flex-direction: column;
  height: 100vh;
  height: 100svh;
  border: none;
  box-sizing: border-box;
  > h1 {
    margin-top: 0;
    margin-bottom: 0;
    > #favicon {
      height: 1em;
      vertical-align: bottom;
    }
  }
  > #chat_content {
    flex-grow: 1;
  }
}

#title, hr {
  border: none;
  border-image: linear-gradient(to right, var(--rainbow)) 1;
  border-bottom-style: solid;
  border-bottom-width: 1px;
}
#qrcode:has(> *), svg.qrcode {
  display: block;
  padding: 20px;
  background: white;
  width:  min(100%, 100vw, 100vh);
  height: min(100%, 100vw, 100vh);
  width:  min(100svw, 100cqw, 100svh, 100cqh, 100%, 100vw);
  height: min(100svw, 100cqw, 100svh, 100cqh, 100%, 100vw);
  margin: auto;
  box-sizing: border-box;
  @media (prefers-color-scheme: dark) {
    transition: opacity 0.5s;
    &:not(:hover) {
      opacity: 0.6;
    }
  }
  &#qrcode>* {
    height: 100%;
    width:  100%;
  }
}

pre {
  margin: 0;
  overflow: auto;
  white-space: pre-wrap;
}

#controls {
  box-sizing: border-box;
  border: 1px solid var(--ui-defocus);
  height: 1.8rem;
  border-radius: 0.9rem;
  padding: 0 0.8rem;
  font-size: 1.2rem;
  display: flex;
  flex-direction: row;
  column-gap: 0.25em;
  &:has(> input#compose:focus) {
    border-color: var(--ui-focus);
  }
  & input {
    box-sizing: border-box;
    border: none;
    border-radius: 0;
    background: none;
    flex-grow: 1;
    align-self: center;
    height: inherit;
    color: inherit;
    font-family: inherit;
    font-size: inherit;
    line-height: 100%;
    text-align: start;
    margin: 0; padding: 0;
    &:focus {
      outline: none;
    }
  }
  &:has(> label[for=file_upload]:first-child) {
    padding-left: 0;
  }
  & label[for=file_upload] {
    flex-grow: 0;
    font-weight: bolder;
    font-size: 1.4rem;
    align-self: center;
    height: 100%;
    border-radius: inherit;
    opacity: var(--ui-semi);
    > svg {
      height: 100%;
      border-radius: inherit;
    }
    &:has(+ #file_upload:not(:disabled)) {
      &:hover, &:focus, &:has(+ #file_upload:focus), &:active {
        opacity: 1;
      }
      &:active, &:has(+ #file_upload:active) {
        color: var(--ui-focus);
      }
      &:focus, &:has(+ #file_upload:focus) {
        color: var(--ui-defocus);
      }
    }
  }
  #file_upload {
    width: 0px;
    height: 0px;
    position: absolute;
    bottom: -20px;
    opacity: 0;
    flex: 0;
    margin-right: -0.25em; /* column-gap */
  }
}

#chat_content, #site_content {
  font-size: 1.2rem;
}
#chat_content {
  display: flex;
  flex-direction: column;
  container: chat_content / size;
  /* bug: https://stackoverflow.com/questions/36130760/use-justify-content-flex-end-and-to-have-vertical-scrollbar#37515194 */
  /* https://bugzilla.mozilla.org/show_bug.cgi?id=1042151 */
  /* https://bugs.chromium.org/p/chromium/issues/detail?id=411624 */
  /* justify-content: flex-end; */
  row-gap: 0.4rem;
  overflow-y: scroll;
  overflow-x: hidden;
  > * {
    flex-grow: 0;
    flex-shrink: 0;
  }
  > :first-child {
    &#chat_spacer {
      flex-grow: 1;
    }
  }
}
#chat_content + #controls {
  margin-top: 0.5rem;
}
.status {
  text-align: center;
  padding: 0.2rem; /* where did this come from */
  font-style: italic;
}
#chat_content > .message {
  position: relative;
  min-height: 1.6rem;
  border-radius: 0.8rem;
  padding: 0.2rem 0.7rem;
  font-size: 1.2rem;
  background: var(--bubble);
  align-content: center;
  box-sizing: border-box;
  display: block;
  &.status {
    justify-content: center;
  }
  &.event {
    opacity: 0.7;
    background: none;
  }
  &.peer, &.echo {
    width: fit-content;
    max-width: calc(100% - 1em);
    max-width: calc(100cqw - 1em);
    &.full-width {
      width: calc(100% - 1em);
      width: calc(100cqw - 1em);
    }
  }
  &.command {
    background: var(--bubble-half);
  }
  &.peer {
    border-top-left-radius: 0;
    align-self: flex-start;
    margin-right: 1em;
  }
  &.echo {
    border-top-right-radius: 0;
    align-self: flex-end;
    margin-left: 1em;
  }
  & img, & video, & canvas, & pre {
    max-width: 100%;
    max-height: 95vh;
    max-height: 95cqh;
  }
  & pre {
    margin: 0;
    overflow: auto;
  }
  &.media, &.color {
    display: flex; /* helps with extraneous line-height padding around <img> */
    padding: 0;
    > img, > video {
      border-radius: inherit;
    }
  }
  > pre {
    margin: 0;
  }
  > :first-child {
    margin-top: 0;
  }
  > :last-child {
    margin-bottom: 0;
  }
  &.shared-message {
    display: flex;
    flex-direction: row;
    max-width: 100%;
    width: 100%;
    margin-left: 0;
    margin-right: 0;
    & textarea {
      background: none;
      color: inherit;
      border-radius: inherit;
      border: none;
      outline: none;
      padding: 0.7rem 0.7rem;
    }
    > .shared-item {
      flex: 1;
    }
    > .shared-sep {
      flex: 0 0 0;
      border-left: 1px solid var(--ui-half);
      margin: 0.2em 0.5em;
    }
  }
}

dt {
  font-weight: bold;
}
dd {
  margin-inline-start: 4ch;
}

div.tabgroup {
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  /* height: max-content;
  max-height: calc(min(95vh, 100%));
  max-height: calc(min(95vh, 100%, 100cqh)); */
  border-radius: 0.8rem;

  &.max-height {
    box-sizing: border-box;
    height: calc(min(95vh, 100%));
    height: calc(min(95vh, 100%, 100cqh));
    & > div.tabs {
      container: tabgroup / size;
    }
  }
  &.raised {
    background: var(--bubble-half);
    margin-left: 2em;
    margin-right: 2em;
  }
  & > div.tablist {
    flex: 0 0 auto;
    display: flex;
    flex-direction: row;
    & > button.tab {
      flex: 1;
      background: none;
      border: none;
      font: inherit;
      color: inherit;
      box-sizing: border-box;
      padding-top: 8px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--ui-half);
      &:hover {
        padding-bottom: 6px;
        border-bottom-width: 4px;
      }
      &.selected {
        color: var(--ui-focus);
        border-bottom-color: var(--ui-focus);
      }
    }
  }
  & > div.tabs {
    flex: auto;
    box-sizing: border-box;
    border-bottom-left-radius: inherit;
    border-bottom-right-radius: inherit;
    & > div.tab {
      border-bottom-left-radius: inherit;
      border-bottom-right-radius: inherit;
      box-sizing: border-box;
      padding: 6px;
      max-height: calc(min(100%, 95vh));
      max-height: calc(min(100%, 100cqh));
      overflow: auto;
      &:has(> svg:only-child, > img:only-child, > video:only-child, > canvas:only-child) {
        padding: 0;
      }
    }
  }
}
</style><!--
            Copyright 2024 Verity J.S.

            Licensed under the Apache License, Version 2.0 (the "License");
            you may not use this file except in compliance with the License.
            You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

            Unless required by applicable law or agreed to in writing, software
            distributed under the License is distributed on an "AS IS" BASIS,
            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            See the License for the specific language governing permissions and
            limitations under the License.
          --><script>"use strict";
function toDataURI(content, mimetype="text/plain") {
  return `data:${mimetype};base64,${toB64(content)}`;
}
function toB64(content) {
  return btoa(Array.from(content instanceof Uint8Array ? content : (new TextEncoder()).encode(content), b=>String.fromCodePoint(b)).join(""));
}
function fromB64(content) {
  return (new TextDecoder()).decode(Uint8Array.from(atob(content), b=>b.codePointAt(0)));
}
fromB64.text = function(content, encoding='UTF-8') {
  return (new TextDecoder(encoding)).decode(fromB64.bytes(content));
}
fromB64.bytes = function(content) {
  return Uint8Array.from(atob(content), b=>b.codePointAt(0));
}
function assert(condition, message="Assertion failed") {
  if (!condition) throw new Error(message);
}
async function readFile(file) {
  const reader = new FileReader();
  return new Promise((resolve, reject) => {
    reader.onerror = reject;
    reader.onload = () => {resolve(reader.result)};
    reader.readAsDataURL(file);
  });
}

function useAnimations() {
  return !window.matchMedia('(prefers-reduced-motion: reduce)').matches;
}

function fragmentData(data, bytes=4_000) {
  const json = data;
  if (json.length < bytes) return [json];
  const segments = [];
  const total = json.length;
  let i = 0;
  while (i < total) {
    const len = Math.min(total - i, bytes - 1);
    // Unit Separator and End of Transmission Block
    const sep = i + len < total ? "\x1F" : "\x17";
    segments.push(json.substring(i, i + len) + sep);
    i += len;
  }
  return segments;
}
function defragmentData() {
  let buffer = [];
  return function next(input) {
    let last = input[input.length-1];
    if (last === "\x1F") {
      buffer.push(input.substring(0,input.length-1));
      return undefined;
    } else if (last === "\x17") {
      buffer.push(input.substring(0,input.length-1));
      const result = buffer.join("");
      buffer = [];
      return result;
    } else {
      assert(!buffer.length, "Dangling transmission (did not see \\x17 ETB segment)");
      return input;
    }
  };
}
function fragmentDC(dc, message) {
  for (const segment of fragmentData(message)) {
    dc.send(segment);
  }
}
function defragmentDC(dc, onmessage) {
  const defragmenter = defragmentData();
  dc.onmessage = (event) => {
    const value = defragmenter(event.data);
    if (value !== undefined) {
      onmessage(value, event);
    }
  };
}

// 52 bits of randomness
function newID() {
  return String(Math.random()).substring(2);
}

const EXAMPLE_FINGERPRINT = "00:F0:01:E0:02:D0:03:C0:04:B0:05:A0:06:90:07:80:08:70:09:60:0A:50:0B:40:0C:30:0D:20:0E:10:0F:00";
const RE_FINGERPRINT = /^(:?[a-fA-F0-9]{2}){32}$/;

// items: { render: Ve.DOM, label: Ve.DOM, value? }[]
function tabgroup(items, onChange) {
  if (!onChange) onChange=()=>{};
  items = Array.from(items).filter(Boolean);
  const tablist = items.map((item, idx) =>
    Ve.HTML.button.tab({
      onclick: () => set(idx),
    }, item.label),
  );
  const tabs = items.map(({ render }) => Ve.HTML.div.tab({hidden:true}, render));
  let current = 0;
  function set(idx) {
    tabs[current].hidden = true;
    tablist[current].classList.remove("selected");
    current = idx;
    tabs[idx].hidden = false;
    tablist[current].classList.add("selected");
    onChange(items[idx].value);
  }
  set(0);
  return Ve.HTML.div.tabgroup([
    Ve.HTML.div.tablist(tablist),
    Ve.HTML.div.tabs(tabs),
  ]);
}

function showTime(when) {
  when = when ? new Date(when) : new Date();
  return Ve.HTML.time({ datetime: String(when) }, when.toLocaleTimeString());
}

function mkCleanup() {
  function cleanup(...args) {
    if (args.length === 0) {
      const todo = cleanup.cleanup;
      cleanup.cleanup = [];
      for (let act of todo) {
        if (act instanceof Node) act = act.removeSelf.bind(act);
        try{act()}catch{}
      }
      return;
    }
    cleanup.cleanup.push(...args);
    return args[0];
  }
  cleanup.cleanup = [];
  return cleanup;
}

function renderJSON(d) {
  return Ve.HTML.pre(JSON.stringify(d, undefined, 2));
}

function safari() {
  if (navigator?.vendor === "Apple Computer, Inc.") return true;
  // if (/iPad|iPhone|iPod/.test(navigator?.platform || "")) return true;
  // // iPad Pro claims it is MacIntel
  // if (navigator?.maxTouchPoints &&
  //     navigator?.maxTouchPoints > 2 &&
  //     /MacIntel/.test(navigator?.platform)) return true;
  return false;
}
function fixSafari() {
  document.head.appendChild(Object.assign(document.createElement('style'), {
    className: 'ephemeral',
    textContent: `
      /* weird fix to prevent Safari from thinking that the body should be scrollable */
      html, body { overflow-y: hidden }
      body { position: sticky }
    `,
  }));
}

if (safari()) {
  if (window.document.readyState === 'complete') {
    fixSafari();
  } else {
    window.addEventListener('DOMContentLoaded', fixSafari);
  }
}
</script><script>"use strict";
function printEvents(label, rtc, cb = () => {}) {
  function snapshot(o) {
    const r = {};
    for (const k of Object.keys(Object.getPrototypeOf(o)).concat(Object.keys(o))) {
      const v = o[k];
      if (typeof v !== 'function') r[k] = v;
      if (v instanceof RTCSessionDescription) r[k] = v.sdp;
    }
    return r;
  }
  function diff(last,o) {
    const r = {};
    for (const [k,v] of Object.entries(o)) {
      if (last[k] !== v) r[k] = v;
    }
    return r;
  }
  let last_rtc = {};
  function diff_rtc() {
    const next = snapshot(rtc);
    const delta = diff(last_rtc, next);
    last_rtc = next;
    return delta;
  }

  const listener = e => {
    const delta = diff_rtc();
    if (label) console.log(label, e.timeStamp, e.type, delta, e);
    const eventJSON = {};
    let p = e;
    while (p && p !== Event.prototype) {
      for (const k of Object.getOwnPropertyNames(p)) {
        try {
          eventJSON[k] = e[k];
        } catch(e){}
      }
      p = Object.getPrototypeOf(p);
    }
    delete eventJSON.isTrusted;
    if (cb) cb(e, delta, eventJSON);
  };

  const events = [];
  for (const k in rtc) if (k.startsWith("on")) events.push(k.substring(2));

  for (const k of events) rtc.addEventListener(k, listener);

  return () => {
    for (const k of events) rtc.removeEventListener(k, listener);
  };
}
</script><script>"use strict";
function makeScrollManagerFor(chat_content, chat_spacer) {
  var chat_scrolling = 0;

  var manager = {
    async adding(addContent, see='bottom') {
      var spacer = chat_spacer.getBoundingClientRect().height;
      // if (role === 'host') console.log({ spacer });
      chat_spacer.style.height = `${spacer}px`;

      var added = addContent();

      await { then(cb) {requestAnimationFrame(cb)} };
      var chatBB = chat_content.getBoundingClientRect();
      var visibleHeight = chatBB.height;
      var target = chat_content.scrollHeight - visibleHeight; // max scroll
      // if (role === 'host') console.log({ target });
      if (see === 'top') {
        var chat_start = chat_content.scrollTop - chatBB.top;
        if (added instanceof Node) {
          added = [added];
        }
        for (let node of added) {
          var top = chat_start + node.getBoundingClientRect().top;
          // if (role === 'host') console.log({ top, node });
          if (top < target) target = top;
        }
      }
      var instantTarget = Math.max(chat_content.scrollTop, target - visibleHeight);

      await manager.scrollTo(instantTarget, target);
      // if (role === 'host') console.log('got to', chat_content.scrollTop);
      await { then(cb) {requestAnimationFrame(cb)} };
      // this RAF prevents weird behavior?? (at least in Chrome)
      // give the browser a chance to catch its breath i guess
      chat_spacer.style.removeProperty('height');
      // if (role === 'host') console.log('got to', chat_content.scrollTop);
    },
    scrollTo(instantTarget, target) {
      // if (role === 'host') console.log(chat_content.scrollTop, instantTarget, target);
      if (chat_content.scrollTop < instantTarget && instantTarget < target-1) {
        chat_content.scrollTo({
          top: (instantTarget + target)/2,
          behavior: 'instant',
        });
      }
      chat_content.scrollTo({
        top: target,
        behavior: useAnimations() ? 'smooth' : 'instant',
      });
      return new Promise(resolve => {
        requestAnimationFrame(manager.monitorScroll(target, resolve));
      });
    },
    monitorScroll(target, onscrollend) {
      var scroll_id = (++chat_scrolling);
      // var last_scroll = chat_content.scrollTop;
      var started = performance.now();
      var listener = () => {
        if (scroll_id !== chat_scrolling) return;
        var this_scroll = chat_content.scrollTop;
        if ((this_scroll >= target - 2) || (performance.now() >= started+1000)) {
          onscrollend();
          chat_scrolling = 0;
          return;
        } else {
          // last_scroll = this_scroll;
          requestAnimationFrame(listener);
        }
      };
      return listener;
    },
    atBottom() {
      var visibleHeight = chat_content.getBoundingClientRect().height;
      return chat_content.scrollTop >= chat_content.scrollHeight - visibleHeight - 2;
    },
  };
  manager.adding.see_bottom = (addContent) => manager.adding(addContent, 'bottom');
  manager.adding.see_top = (addContent) => manager.adding(addContent, 'top');
  return manager;
}
</script><script>////////////////////////////////////////////////////////////////////////////////
// You should not consider this file as normal JavaScript objects that play   //
// nicely with the runtime and assumptions that code and handlers make. You   //
// should consider this (not-so-smol) library as a way of enabling syntax     //
// that you (I) might like to write. Hopefully there are enough examples to   //
// give you a good idea of what uses we intend for them, what the suggested   //
// syntax is.                                                                 //
////////////////////////////////////////////////////////////////////////////////
Verity = Ve = {};
(function Veritification() {
  Ve.noop = ()=>{};

  function pythonic(fn) {
    return function(...args) {
      return fn(this, ...args);
    };
  };

  //////////////////////////////////////////////////////////////////////////////
  // Lots of silly syntax sugar, that makes use of Proxies! (also getters and //
  // `defineProperty` and so on). This is basically to maintain my philosophy //
  // that fixed identifiers should appear as identifiers in the source code   //
  // (kind of like how Erlang treats “atoms”), rather than as strings.        //
  //////////////////////////////////////////////////////////////////////////////

  // Create a simple proxy for syntactic sugar for method names and function calls
  const sugar = (handler, applier=undefined) => new Proxy(applier ? ()=>{} : {}, {
    get: (_target, property, _thisArg) => {
      return handler(property);
    },
    apply: applier && ((_target, _thisArg, args) => applier(...args)),
  });
  const sugarArg = handler => sugar(handler, handler(undefined));
  const sugarStr = handler => sugar(handler, handler)

  // Create a getter for the property:
  //     _.name = v => v.name
  //     _.name({name:"hello"}) == "hello"
  //
  // Or create a function that applies fixed arguments:
  //     _("la", "la") = fn => fn("la", "la")
  //     _("la", "la")(Array) = ["la", "la"]
  const _ = sugar(
    name => value => value[name],
    // Capture `this` from the second call, so that
    // ({ foo: "bar" }) == _().call({ foo: "bar" }, (function () { return this }))
    (...args) => function (fn) { return fn.call(this, ...args) }
  );

  // Another kind of getter, on `this` instead of the first argument.
  //     _this.prop = function(){ return this.prop };
  //     _this.prop.call({ prop: 5 }) == 5
  // As a function, it just returns `this`, which is useful in composition
  // pipelines or so forth.
  const _this = sugar(
    name => function() { return this[name] },
    function() { return this },
  );

  // Create a wrapper for the property:
  //     mk.name = name => ({ name })
  //     mk.name("hello") == {name: "hello"}
  const mk = sugar(
    name => value => ({ [name]: value }),
  );

  // Create a modifier for the property:
  //     modifier.name(fn) = value => ({ ...value, name: fn(value.name) })
  //     modifier.name(x => x.join(""))({ name: ["Monoid", "Musician"], value: 42 }) == { name: "MonoidMusician", value: 42 }
  // Works in reverse too:
  //     modifier(fn).name = value => ({ ...value, name: fn(value.name) })
  //     modifier(x => x.join("")).name({ name: ["Monoid", "Musician"], value: 42 }) == { name: "MonoidMusician", value: 42 }
  const modifier = sugar(
    name => fn => value => ({ ...value, [name]: fn(value[name]) }),
    fn => sugar(name => value => ({ ...value, [name]: fn(value[name]) })),
  );

  // Thatʼs the easy stuff. Letʼs dig deeper!

  // The identity function. You know it and love it. <3
  const identity = v => v;

  // Could this be a name of a method? Note that `new String("")` objects do not
  // count, nor do numbers. In particular, note that
  //     typeof sugar(identity)[new String("x")] != typeof new String("x")
  const _isMethod = p => typeof p === 'string' || typeof p === 'symbol';

  // Compose left to right (the first function can take multiple arguments and
  // also the implicit `this` reference). If a function is a string or symbol,
  // it is treated as a method name (this preserves the parent object as
  // the `this` reference for the next function in the composition pipeline).
  const compose = (...allFns) => {
    // Comparing functions is bad but I just think it is funny if it strictly
    // satisfies the category laws for the wrong reasons:
    const fns = allFns.filter(x => x !== identity);

    if (!fns.length) return identity;

    const fn0 = _isMethod(fns[0]) ? (v => v[fns[0]]) : fns[0];
    if (fns.length === 1) return fn0;

    // Return a function that can capture `this` and thus operate like a method.
    return function(...args) {
      // Start by applying the original `this` and `args`
      let v = fn0.call(this, ...args);
      // We preserve the last object as `thisArg` iff the function is a string
      // for a method name
      let thisArg = _isMethod(fns[0]) ? args[0] : undefined;
      for (let fn of fns.slice(1)) {
        if (_isMethod(fn)) {
          // For method names we take the value of the property and preserve
          // the old object as the new `thisArg`
          thisArg = v;
          v = v[fn];
        } else {
          // For functions, we call them with the current value of `thisArg`
          // (which is only defined if the last function was a method name)
          // and then set the next `thisArg` to `undefined`.
          v = fn.call(thisArg, v);
          thisArg = undefined;
        }
      }
      return v;
    };
  };

  // Collect arguments to compose via proxied member/method/function applications.
  const pipelining = (pipelined, finit="line_") => new Proxy(()=>{}, {
    get: (_target, property, _thisArg) => {
      // Special case to end the pipeline
      // (yeah, it could be a symbol to be pedantic about abstraction,
      // but that makes it less symmetrical!)
      if (property === finit) return compose(...pipelined);

      // See documentation for `compose` for why this is inserted as
      // a string/symbol still, instead of `_[property]`:
      return pipelining([ ...pipelined, property ], finit);
    },
    apply: (_target, _thisArg, args) => {
      return pipelining([ ...pipelined, _(...args) ], finit);
    },
  });

  // Create a pipeline of `_`-style accessors that end with `.line_`:
  //     _pipe.join("").line_ = x => x.join("")
  //     _pipe.join(", ").line_(["do", "re", "mi"]) == "do, re, mi"
  //     _pipe.join(", ").length.line_(["do", "re", "mi"]) == 10
  const _pipe = pipelining([], "line_");

  const intercalate = (fixed, ...intermediates) => {
    const result = [];
    fixed.forEach((item, i) => {
      result.push(item);
      if (i < fixed.length - 1)
        result.push(intermediates[i]);
    });
    return result;
  };
  intercalate.raw = ({ raw: fixed }, ...intermediates) => {
    return intercalate(fixed, ...intermediates);
  };

  //////////////////////////////////////////////////////////////////////////////
  // That was originally made as its own little thing. Now we get into the    //
  // rest of my convenience functions and library, under the `Ve`/`Verity`    //
  // namespace.                                                               //
  //////////////////////////////////////////////////////////////////////////////

  Object.assign(Ve, {
    sugar, _, _this, mk, modifier, compose, _pipe, intercalate,
  });

  // Create a `String` object whose value is computed on demand
  //     Ve.StringOnDemand(() => "hi") instanceof String == true
  //     String(Ve.StringOnDemand(() => "hi")) == "hi"
  //     Ve.StringOnDemand(() => "hello") + " world" == "hello world"
  Ve.StringOnDemand = fn => Object.create(Object.assign(new String(), { toString: fn, valueOf: fn }));

  // Create a `Number` object whose value is computed on demand
  //     Ve.NumberOnDemand(() => Math.random()) instanceof Number == true
  //     Number(Ve.NumberOnDemand(() => Math.PI)) == Math.PI
  //     Ve.NumberOnDemand(() => 2) + 3 == 5
  Ve.NumberOnDemand = fn => Object.create(Object.assign(new Number(), { valueOf: fn }));

  //////////////////////////////////////////////////////////////////////////////
  // DOM library. It is not a VDOM library, just convenience helpers for      //
  // making constructing DOM nodes much more pleasant!                        //
  //////////////////////////////////////////////////////////////////////////////

  // Special properties, or properties that already exist but deserve some
  // special handling.
  //
  // There is currently an unresolved tension between wanting to have the
  // properties apply cleanly, versus having it be compositional. We really
  // should have a DOM that is properly monoidal, but that is beyond the scope
  // here... (think about if all DOM properties and attributes and CSS
  // properties had sensible ways to combine together and work compositionally!)
  var SPECIALS = {
    style: (e, style) =>
      style && Object.assign(e.style, typeof style === 'string' ? {style} : style),
    attrs: (e, attrs) =>
      attrs && Object.assign(e.attrs, attrs), // see Element.prototype.attrs below
    data: (e, attrs) =>
      attrs && Object.assign(e.dataset, attrs),
    dataset: (e, attrs) =>
      attrs && Object.assign(e.dataset, attrs),
    $parent: (e, parent) =>
      parent && parent !== e.parentNode && parent.appendChild(e),
    $textContent: (e, textContent) =>
      e.textContent = textContent,
    $children: (parent, topChildren) => {
      parent.clearChildren();
      function go(children) {
        if (typeof children === 'function') children = children();
        if
          ( typeof children === 'string' || children instanceof String
          || typeof children === 'number' || children instanceof Number
          || children instanceof Node
          )
          children = [children];
        if (!children) return;
        for (let child of children) {
          if (child === undefined || child === null) continue;
          if (Array.isArray(child)) {
            go(child);
          } else {
            parent.appendChild(createChildOf(parent, child));
          }
        }
      }
      go(topChildren);
      return parent;
    },
    classList: (e, classes) => {
      e.classList = '';
      if (classes) {
        if (typeof classes === 'string' || classes instanceof String) {
          e.classList = String(classes);
        } else {
          e.classList.add(...classes.flatMap(x=>x.split(/\s+/u).filter(Boolean)));
        }
      }
    },
    // I probably donʼt need so many names for it ...
    class: (...arg) => SPECIALS.classList(...arg),
    // Yeah I kind of wanted a MVC type thing, but I never got around to it.
    // $view: (e, view) =>
    //   view && (e.$view = view),
    // $preview: (e, preview) =>
    //   preview && (e.$preview = preview),
    // $model: (e, model) =>
    //   e.MVC(model, e.$view),
  };
  // Apply (special) properties to the specified DOM element.
  function applyProps(e, props) {
    props = props ? Object.assign({}, props) : {};
    var specialProps = {};
    for (let k in props) {
      if (k in SPECIALS) {
        specialProps[k] = props[k];
        delete props[k];
      } else if (k.startsWith('$')) {
        console.warn(`Warning: unknown special attribute ${k} on element`, e);
        delete props[k];
      }
    }
    var hadChildren = '$children' in specialProps;
    for (let k in props) {
      if (/\d+/.test(k)) {
        if (hadChildren) throw new Error("Cannot mix numeric and $children");
        if (!('$children' in specialProps)) specialProps['$children'] = [];
        specialProps['$children'][k] = props[k];
        delete props[k];
      }
    }
    Object.assign(e, props);
    for (let k in specialProps) {
      SPECIALS[k](e, specialProps[k]);
    }
    return e;
  };
  function createChildOf(parent, props, tag, ...children) {
    return createElementNS(parent?.namespaceURI, props, tag, ...children);
  }
  function createElementNS(namespaceURI, props, tag, ...children) {
    const resolved = precreateElementNS(namespaceURI, props, tag, ...children);
    return createElementResolved(resolved);
  }
  function createElementResolved({ namespaceURI, props, tag, children }) {
    if (!tag && !props) {
      if (children?.length === 1) {
        return children[0];
      } else {
        const result = document.createDocumentFragment();
        SPECIALS['$children'](result, children);
        return result;
      }
    }
    let e = namespaceURI
      ? document.createElementNS(namespaceURI || undefined, tag)
      : document.createElement(tag);
    if (children?.length) props['$children'] = children;
    applyProps(e, props);
    return e;
  }
  function precreateElementNS(namespaceURI, props, tag, ...children) {
    if (typeof tag === 'function') tag = tag();
    if (typeof props === 'string' || typeof props === 'number' || props instanceof String || props instanceof Number) {
      children = [document.createTextNode(String(props)), ...children];
      props = undefined;
    } else if (props instanceof Node) {
      children = [props, ...children];
      props = undefined;
    } else if (Array.isArray(props)) {
      children = [...props, ...children];
      props = undefined;
    }
    props = props ? Object.assign({}, props) : undefined;
    if (props) {
      tag = tag || props['$tag'];
      if (!tag) tag = 'div';
      delete props['$tag'];
      namespaceURI = namespaceURI || props['$NS'];
      delete props['$NS'];
      if (props['$children'])
        children = [props?.['$children'], children];
      delete props['$children'];
    } else if (tag) {
      props = {};
    }
    if (tag instanceof Element) tag = tag.tagName;
    if (namespaceURI instanceof Element) namespaceURI = namespaceURI.namespaceURI;
    return { namespaceURI, tag, props, children };
  };

  Object.assign(Ve, {
    applyProps, createChildOf,
    createElementNS, createElementResolved, precreateElementNS,
  });

  // This is nice little sugar to grab an element by ID out of the DOM!
  Ve.ById = sugar(id => document.getElementById(id));

  // Common XML namespaces ... SVG is the only one that really matters fo
  // making DOM operations work, but XHTML is the default for HTML documents
  // already (it is not necessary to specify, but it exists).
  Ve.NS = {
    SVG: "http://www.w3.org/2000/svg",
    XHTML: "http://www.w3.org/1999/xhtml",
    HTML: "XHTML", // DRY
    XLink: "http://www.w3.org/1999/xlink",
    XML: "http://www.w3.org/XML/1998/namespace",
    XMLNS: "http://www.w3.org/2000/xmlns/",
  };
  for (let k in Ve.NS) if (Ve.NS[k] in Ve.NS) Ve.NS[k] = Ve.NS[Ve.NS[k]];
  for (let k in Ve.NS) Ve.NS[k.toLowerCase()] = Ve.NS[k];

  // Templating a DocumentFragment out of strings (text nodes) and other
  // nodes/descriptions of node properties.
  Ve.DOM = (fixed, ...args) => {
    return createChildOf(null, Ve.dedent.intercalate(fixed, ...args));
  };
  // Template a DOM node on a (sugared) namespace. There is a looot of
  // flexibilty in how it can be used. See below for examples.
  Ve.DOM.NS = sugarStr(ns => sugarArg(tag => sugarArg(cls => (props = {}, ...children) => {
    if (ns in Ve.NS) ns = Ve.NS[ns];
    // hint that props needs to exist
    if (!props && cls) props = {};
    const resolved = precreateElementNS(ns, props, tag, ...children);
    if (cls) resolved.props.class = cls;
    return createElementResolved(resolved);
  })));

  // Create an HTML DOM node based on describing its properties, children, and
  // so on.
  Ve.HTML = Ve.DOM.NS.HTML;
  Ve.SVG = Ve.DOM.NS.SVG;

  // Helper for an icon, based on its class.
  Ve.ico = sugarStr(classList => Ve.HTML.i({classList}));
  // Helper for an iconoir icons, based on its class.
  Ve.iconoir = sugarStr(classList => {
    const prepend = s => `iconoir-${s.replaceAll('_','-')}`;
    if (typeof classList === 'string' || classList instanceof String) {
      classList = [prepend(classList)];
    } else {
      classList = [...prepend(classList[0]), classList.slice(1)];
    }
    return Ve.HTML.i({classList});
  });
  Ve.button = onclick => ({})

  // A helper for event handlers that returns an unsubscribe function, instead
  // of having to keep the original function around. For `Element`s,
  // `Ve.on.click(tgt, handler, options)` can also be written as
  // `tgt.on.click(handler, options)` with the magic of prototype pollution,
  // but `Ve.on` is a global method if you prefer that, or are working with
  // other event sources (like `window`).
  Ve.on = sugarStr(tys => (tgt, handler, options) => {
    if (!handler && !options) {
      return CbAndPromise(
        (handler, options) => Ve.on(tys)(tgt, handler, options),
        handler => Ve.once(tys)(tgt, handler),
      );
    }
    if (typeof options === 'function' && typeof handler !== 'function') {
      [handler, options] = [options, handler];
    };
    if (typeof tys === 'string' || tys instanceof String) tys = tys.split(',');
    for (const ty of tys) tgt.addEventListener(ty, handler, options);
    return () => {
      for (const ty of tys) tgt.removeEventListener(ty, handler, options);
      tgt = null; handler = null; options = null;
    };
  });
  // `Ve.once` is like `Ve.on` but it sets the `{once:true}` option.
  Ve.once = sugarStr(tys => (tgt, handler, options) => {
    if (!handler && !options) {
      return PromiseOrCb((handler, options) => Ve.once(tys)(tgt, handler, options));
    }
    if (typeof options === 'function' && typeof handler !== 'function') {
      [handler, options] = [options, handler];
    };
    options = Object.assign({}, options, {once:true});
    return Ve.on(tys)(tgt, handler, options);
  });
  // Run synchronously without delay.
  Ve.immediately = (cb, ...args) => {
    cb(...args);
    return Ve.noop;
  };

  // Some useful shorthands. Should be used with object spread if you need
  // multiple.
  Ve.styl = {
    inline: { display: 'inline' },
    block: { display: 'block' },
    flex: { display: 'flex' },
    flexColumn: { display: 'flex', flexDirection: 'column' },
    flexRow: { display: 'flex', flexDirection: 'row' },
    marginAuto: { margin: 'auto' },
    pointer: { cursor: 'pointer' },
    textCursor: { cursor: 'text' },
  };

  Ve.CSS = Object.create(window.CSS);
  // Just so you can remember what `:root` corresponds to, since it is all
  // the rage now. Specified as a getter just in case it mutates or something.
  Object.defineProperty(Ve.CSS, ":root", { get: () => window.document.documentElement });
  // Return the (root) `Element`, where we should look for styles, on the
  // specified document, an element itself, or the default `<html>` root.
  Ve.CSS.styleRoot = function(tgt=undefined) {
    if (tgt instanceof Element) return tgt;
    if (tgt instanceof Document) return tgt.documentElement;
    return window.document.documentElement;
  };
  // Return the `.style` attribute of the `styleRoot` (as defined above).
  // Can return the computed style, if requested with `computed=true`.
  Ve.CSS.rootStyle = function(tgt=undefined, computed=false) {
    if (tgt instanceof CSSStyleDeclaration) return tgt;
    tgt = Ve.CSS.styleRoot(tgt);
    return computed ? getComputedStyle(tgt) : tgt.style;
  };

  // `getVars` would require parsing stylesheets :-/
  // Ve.CSS.getVars = function(tgt) {};

  // Get a CSS variable, optionally on the target, but by default on the
  // document root (CSS `:root`). Note: this uses the computed style, since that
  // is more relevant for getting variables specified in style sheets, but
  // this means that its original string value (with `var()`s) is not available!
  Ve.CSS.getVar = function(name, tgt=undefined, computed=true) {
    const style = Ve.CSS.rootStyle(tgt || this, computed);
    return style.getPropertyValue(`--${name}`);
  };
  // Get or set a (global) CSS variable (depending on the number of arguments).
  Ve.CSS.etVar = function(...args) {
    if (args.length > 1) return Ve.CSS.setVar.call(this, ...args);
    return Ve.CSS.getVar.call(this, ...args);
  };
  // Set a variable, on the target or on `:root`.
  Ve.CSS.setVar = function(name, value, tgt=undefined) {
    const style = Ve.CSS.rootStyle(tgt || this, false);
    if (value === null || value === undefined) {
      style.removeProperty(`--${name}`);
    } else {
      style.setProperty(`--${name}`, value);
    }
  };
  // Set variables, specified as an object.
  Ve.CSS.setVars = function(values, tgt) {
    const style = Ve.CSS.rootStyle(tgt || this, false);
    for (let [name, value] of Object.entries(values)) {
      if (value === null || value === undefined) {
        style.removeProperty(`--${name}`);
      } else {
        style.setProperty(`--${name}`, value);
      }
    }
  };
  // I could not decide what to name this.
  Ve.__var = Ve.CSS.var = Ve.CSS.__ = Ve.CSS.__var = new Proxy(Ve.CSS.etVar, {
    get(__, name, tgt) {
      return Ve.CSS.getVar.call(tgt, name);
    },
    set(_, name, value, tgt) {
      Ve.CSS.setVar.call(tgt, name, value);
      return true;
    },
  });

  //////////////////////////////////////////////////////////////////////////////

  Ve.DynParams = function(getFragment, setFragment, plural=false) {
    if (!setFragment) setFragment = undefined;

    let fragment;
    let params;
    const getParams = () => {
      let last = fragment;
      fragment = getFragment();
      if (!params || last !== fragment)
        return params = new URLSearchParams(fragment);
      return params;
    };
    const modifyParams = (fn) => {
      const params = getParams();
      const result = fn(params) ?? params;
      if (result === false) return false;
      if (result) {
        setFragment(result);
        fragment = undefined;
      }
      return true;
    };

    return new Proxy({}, {
      get: (_, name) => plural ? getParams().getAll(name) : getParams().get(name),
      ownKeys: () => [...new Set(getParams().keys())],
      has: (_, name) => getParams().has(name),
      set: setFragment && ((_, name, value) => modifyParams(params => {
        if (value instanceof Array) {
          params.delete(name);
          for (const v of value) {
            params.append(name, v);
          }
        } else {
          params.set(name, value);
        }
      })),
      deleteProperty: setFragment && ((_, name) => modifyParams(params => {
        params.delete(name);
      })),
    });
  };
  Ve.Params = {
    _withPrefix: (prefix, setter, that=undefined) => {
      if (typeof setter === 'string') {
        return [
          () => {
            let v = (that||window.location)[setter];
            if (v.startsWith(prefix)) {
              v = v.substring(prefix.length);
            }
            return v;
          },
          Ve.Params._withPrefix(prefix, v => {
            if (that) that[setter] = v; else
              window.history.replaceState(null, "", Object.assign(new URL(window.location), {[setter]: v}));
          }),
        ];
      }
      return params => {
        console.log(params, String(params));
        params = String(params);
        if (params) setter.call(that, prefix + params);
        else setter.call(that, "");
      };
    },
  };
  Object.assign(Ve.Params, {
    _search: Ve.Params._withPrefix(`?`, 'search'),
    _hash: Ve.Params._withPrefix(`#`, 'hash'),
  });
  Object.assign(Ve.Params, {
    search: Ve.DynParams(...Ve.Params._search, false),
    hash: Ve.DynParams(...Ve.Params._hash, false),
    all: {
      search: Ve.DynParams(...Ve.Params._search, true),
      hash: Ve.DynParams(...Ve.Params._hash, true),
    },
  });
  Ve.Params.query = Ve.Params.search;
  Ve.Params.all.query = Ve.Params.all.search;

  //////////////////////////////////////////////////////////////////////////////
  // Convenience network methods, wrappers around `fetch()`, defaulting to    //
  // JSON but can also return the underlying request if you set the `Accept`  //
  // header to another mime type                                              //
  //////////////////////////////////////////////////////////////////////////////

  Ve.GET = async (url, options) => {
    const decisions = {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
    };
    if (typeof options === 'string') {
      decisions.headers['Accept'] = options;
    } else if (typeof options === 'object') {
      Object.assign(decisions, options, {
        headers: Object.assign(decisions.headers, options.headers),
      });
    }
    let r = await fetch(url, decisions);
    if (decisions.headers['Accept'] === 'application/json') r = r.json();
    return r;
  };

  Ve.DELETE = async (url, options) => {
    const decisions = {
      method: 'DELETE',
    };
    if (typeof options === 'object') {
      Object.assign(decisions, options);
    }
    let r = await fetch(url, decisions);
    r = r.text();
    return r;
  };

  Ve.POST = async (url, data, options) => {
    const decisions = {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    };
    if (typeof options === 'string') {
      decisions.headers['Accept'] = options;
    } else if (typeof options === 'object') {
      Object.assign(decisions, options, {
        headers: Object.assign(decisions.headers, options.headers),
      });
    }
    let r = await fetch(url, decisions);
    if (decisions.headers['Accept'] === 'application/json') r = r.json();
    return r;
  };

  Ve.PUT = async (url, data, options) => {
    const decisions = {
      method: 'PUT',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    };
    if (typeof options === 'string') {
      decisions.headers['Accept'] = options;
    } else if (typeof options === 'object') {
      Object.assign(decisions, options, {
        headers: Object.assign(decisions.headers, options.headers),
      });
    }
    let r = await fetch(url, decisions);
    if (decisions.headers['Accept'] === 'application/json') r = r.json();
    return r;
  };

  //////////////////////////////////////////////////////////////////////////////
  // ~~Prototype pollution~~ Global amenities ^^                              //
  //////////////////////////////////////////////////////////////////////////////

  Object.defineProperties(EventTarget.prototype, {
    // Event handlers (permanent and single-shot). Returns a destructor.
    //     ignore = Ve.ById.my_canvas.on.mousemove(ev => console.log(ev), {});
    on: {
      get: function () {
        return sugar(ty => (handler, options) => Ve.on[ty](this, handler, options));
      },
    },
    once: {
      get: function () {
        return sugar(ty => (handler, options) => Ve.once[ty](this, handler, options));
      },
    },
  });

  Object.defineProperties(Element.prototype, {
    // Attributes of the DOM Element
    attrs: {
      get: function () {
        // arrow functions so `this` still refers to the `Element`
        return new Proxy({}, {
          get: (_, p) => this.getAttribute(p),
          set: (_, p, v) => { this.setAttribute(p, v); return true; },
          ownKeys: (_) => this.getAttributeNames(),
        });
      },
      // Set them all at once, thus overwriting what was previously there
      // (so `getAttributeNames` should return the same keys, barring DOM
      // weirdness).
      set: function (newAttrs) {
        this.clearAttributes();
        Object.assign(this.attrs, newAttrs);
        return true;
      },
    },
    // Scoped CSS variables
    __var: {
      get: function () {
        return new Proxy({}, {
          // arrow functions so `this` still refers to the `Element`
          get: (_, p) => Ve.CSS.getVar.call(this, p),
          set: (_, p, v) => { Ve.CSS.setVar.call(this, p, v); return true; },
        });
      },
    },
  });


  Element.prototype.applyProps = pythonic(applyProps);
  Element.prototype.getAttributes = function() {
    return Object.fromEntries(this.getAttributeNames().map(name => [name, this.getAttribute(name)]));
  };
  Element.prototype.setAttributes = function(attrs) {
    for (let [name, value] in Object.entries(attrs)) {
      this.setAttribute(name, value);
    }
  };
  Element.prototype.clearAttributes = function() {
    for (let attr of this.getAttributeNames()) {
      this.removeAttribute(attr);
    }
  };
  Element.prototype.copyAttributes = function(copyFrom) {
    this.setAttributes(copyFrom.getAttributes());
  };
  Node.prototype.clearChildren = function() {
    for (let c of Array.from(this.children)) {
      c.removeSelf();
    }
  };
  Node.prototype.removeSelf = function() {
    this.parentNode.removeChild(this);
  };

  // Useful for typed DOM APIs like `document.querySelectorAll`
  Ve.forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  Ve.forQuery = (query, cb) => {
    const results = [];
    const selected = window.document.querySelectorAll(query);
    Ve.forEach(selected, (...args) => {
      results.push(cb ? cb(...args) : args[0]);
    });
    return results;
  };

  // Itʼs useful to be able to use some APIs as either promises or callback functions.
  // Most of the callbacks below are in the style that return their destructors,
  // instead of holding onto IDs. Note that this is not a proper `Promise`,
  // since that queues on the microtask queue! And also because it does not
  // execute until `.then()` is called! (Lazy promise? Coroutine? idk.)
  // It is really just a hack for `await` syntax, letʼs be honest.
  // (*shakes fist* why donʼt promises support cancellation.)
  var CbAndPromise = (executor, then) =>
    Object.assign(executor, {
      then: then || ((...args) => executor(...args))
    });
  var PromiseOrCb = executor =>
    CbAndPromise(executor, (cb) => executor(cb)); // no extra arguments

  // A `setTimeout` that returns its `clearTimeout` for you to call later,
  // if you need to. Or also useable as a promise. Fixes my main gripe with the
  // standard API: now we can have the timeout come first, and then the function
  // afterwards, so that the syntax is nicer and the specific number does not
  // get lost after the whole body of the function. Supports partial application
  // and use as a promise. Also passes extra arguments if provided.
  Ve.TimeoutMs = (timeout, cb, ...args) => {
    if (!cb) return PromiseOrCb(
      (resolve, ...args) => Ve.TimeoutMs(timeout, resolve, ...args),
    );
    let id = setTimeout(() => {
      const r = cb(...args);
      cb = undefined; args = undefined;
      return r;
    }, timeout);
    // Try to avoid some space leaks. Ugh.
    return () => { clearTimeout(id); cb = undefined; args = undefined; };
  };

  // `Promise.resolve` (and any promise that resolves “immediately”) is the
  // only way to access the microtask queue. Fun fact: I didnʼt know that it
  // existed until ~last year! I thought callbacks were called immediately/
  // synchronously, like you would do if you were implementing Promises naïvely.
  Ve.Microtask = PromiseOrCb((cb, ...args) => {
    Promise.resolve().then(() => { if (cb) return cb(...args) });
    return () => { cb = undefined; args = undefined; };
  });

  // Good olʼ `requestAnimationFrame`/`cancelAnimationFrame`.
  Ve.RAF = Ve.AnimationFrame = PromiseOrCb((cb, ...args) => {
    let id = requestAnimationFrame(() => {
      const r = cb(...args);
      cb = undefined; args = undefined;
      return r;
    });
    // Try to avoid some space leaks. Ugh.
    return () => { cancelAnimationFrame(id); cb = undefined; args = undefined; };
  });

  // `requestIdleCallback`/`cancelIdleCallback`. I also didnʼt know this API
  // existed until it showed up in autocomplete.
  Ve.Idle = PromiseOrCb((cb, ...args) => {
    let id = requestIdleCallback(() => {
      const r = cb(...args);
      cb = undefined; args = undefined;
      return r;
    });
    // Try to avoid some space leaks. Ugh.
    return () => { cancelIdleCallback(id); cb = undefined; args = undefined; };
  });

  // `DOMContentLoaded` unless `document.readyState === 'complete'` already
  Ve.ContentLoad = PromiseOrCb((cb, ...args) => {
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState
    // 'loading', 'interactive', 'complete'
    //
    // interactive
    //   The document has finished loading and the document has been parsed but
    //   sub-resources such as scripts, images, stylesheets and frames are still
    //   loading. The state indicates that the DOMContentLoaded event is about
    //   to fire.
    if (window.document.readyState === 'complete') {
      return Ve.immediately(cb, undefined, ...args);
    } else {
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event
      // The DOMContentLoaded event fires when the HTML document has been
      // completely parsed, and all deferred scripts (<script defer src="…"> and
      // <script type="module">) have downloaded and executed. It doesnʼt wait
      // for other things like images, subframes, and async scripts to finish
      // loading.
      //
      // DOMContentLoaded does not wait for stylesheets to load, however
      // deferred scripts do wait for stylesheets, and the DOMContentLoaded
      // event is queued after deferred scripts. Also, scripts which arenʼt
      // deferred or async (e.g. <script>) will wait for already-parsed
      // stylesheets to load.
      //
      // A different event, load, should be used only to detect a fully-loaded
      // page. It is a common mistake to use load where DOMContentLoaded would
      // be more appropriate.
      return Ve.once.DOMContentLoaded(window, (event) => cb(event, ...args));
    }
  });
  // `window.onload` unless `document.readyState === 'complete'` already
  Ve.FullLoad = PromiseOrCb((cb, ...args) => {
    if (window.document.readyState === 'complete') {
      return Ve.immediately(cb, undefined);
    } else {
      return Ve.once.load(window, (event) => cb(event, ...args));
    }
  });

  //////////////////////////////////////////////////////////////////////////////

  Ve.RAFBuffer = function() {
    let buffer = [];
    let flushing = false;
    function flush() {
      flushing = true;
      let buffered = buffer;
      while (buffered.length) {
        console.log("Buffered", buffered.length);
        buffer = [];
        for (let event of buffered) {
          event[0].call(event[1], ...event[2]);
        }
        buffered = buffer;
      }
      flushing = false;
    }
    return function(cb) {
      return function(...event) {
        if (!buffer.length && !flushing) requestAnimationFrame(flush);
        buffer.push([cb, this, event]);
      };
    };
  }
  Ve.AggregateRAF = function(handle) {
    let buffer = [];
    function flush() {
      const buffered = buffer;
      buffer = [];
      handle(buffered);
    }
    return function(datum) {
      if (!buffer.length) requestAnimationFrame(flush);
      buffer.push(datum);
    };
  }

  // Fucked code that does not work.
  Ve.$Buffer = Symbol("buffer");
  Ve.BufferEv = (upstream, cb) => {
    let buffer = [];
    let buffered = new Proxy(upstream, {
      get: (tgt, name, receiver) => {
        if (name === Ve.$Buffer) return buffer;
        if (name === "addEventListener") {
          return Object.assign(function addEventListener(...args) {
            if (!this[Ve.$Buffer]) {
              return this.addEventListener(...args);
            }
            const outer = this;
            const originalCb = args[1];
            function bufferEvent(...event) {
              console.log("Capture", event);
              if (cb && !outer[Ve.$Buffer].length) {
                cb(() => { console.debug("FLUSH"); buffered.flush(); });
              }
              outer[Ve.$Buffer].push([originalCb, this, ...event]);
            }
            return this.addEventListener.original.call(this.addEventListener.upstream, args[0], bufferEvent, ...args.slice(2));
          }, { upstream, original: tgt.addEventListener });
        }
        if (name === "flush") {
          return function flush() {
            const toRun = buffer;
            buffer = [];
            for (let event of toRun) {
              console.log(event);
              event[0].call(event[1], event.slice(2));
            }
          };
        }
        return Reflect.get(tgt, name);
      }
    });
    return buffered;
  };
  Ve.BufferEvRAF = (upstream) => Ve.BufferEv(upstream, requestAnimationFrame);

  //////////////////////////////////////////////////////////////////////////////
  // Mutation observer stuff (TODO)                                           //
  //////////////////////////////////////////////////////////////////////////////

  // https://stackoverflow.com/questions/31659567/performance-of-mutationobserver-to-detect-nodes-in-entire-dom#39332340

  //////////////////////////////////////////////////////////////////////////////

  // Intended for embedding files with some interpolations. This is my custom
  // algorithm for dedenting a template literal. It takes the raw string,
  // without escape codes, and it computes and strips leading indentation from
  // each line (if it is not whitespace). Finally it
  //
  // Notes on behavior:
  // - Takes raw string values
  // - Ignores the interpolations for the sake of indentation
  // - Computes and removes common indentation from non-blank lines
  // - Lines that consist solely of whitespace are ignored for the purposes of
  //   indentation:
  //   - If all lines lack content, it returns '\n'*(number of newlines - 1)
  //     (that is: it should return two newlines when your editor shows
  //     two blank lines)
  //   - Otherwise, it removes up to one newline from the start and end, so that
  //     the backtick delimiters can be on their own lines. Again: a fully
  //     blank line in the editor becomes a '\n' in the output.
  //
  // This should allow you to represent almost any string you want in a
  // reasonable and nicely indented manner, with the exception of strings that
  // contain trailing whitespace on lines (shudder), and strings with '\r' or
  // '\f' (it makes very little effort to preserve newlines other than '\n').
  Ve.dedent = (strings, ...values) => {
    return Ve.dedent.intercalate(strings, ...values).join('');
  };
  // This returns the alternating [string, value, string, value, ..., string]
  // array (where the values are not coerced to strings!), as opposed to the
  // concatenated string.
  Ve.dedent.intercalate = (strings, ...values) => {
    if ('raw' in strings) strings = strings['raw'];
    if (typeof strings === 'string' || strings instanceof String) strings = [strings];
    if (!strings.length) return '';
    const lines = strings.flatMap((string, i) => {
      const these_lines = string.split('\n').slice(1);
      return these_lines.map((line, j) => {
        return {line, follows: i !== strings.length-1 && j === these_lines.length-1};
      });
    });

    // The algorithm doesnʼt work for single-line literals
    if (!lines.length) return Ve.intercalate(strings, ...values);

    // Compute the common prefix
    let commonPrefix = null;
    for (const {line, follows} of lines) {
      const prefix = line.match(/^[^\S\r\n\f]*/u)[0];
      if (!follows && prefix === line) continue; // no content
      if (!commonPrefix || commonPrefix.startsWith(prefix)) {
        commonPrefix = prefix;
      }
      if (!commonPrefix) break;
    }
    // Remove the common prefix from the strings, or if they are all blank,
    // zero them out so that it returns only newlines.
    const replaced =
      commonPrefix === null ? strings.map(s => s.split('\n').map(_=>'').join('\n')) :
      strings.map(string => string.replaceAll('\n'+commonPrefix, '\n'));
    // If there is no content on the first line, remove it
    if (!replaced[0].split("\n")[0].trim())
      // https://forum.keyboardmaestro.com/t/regex-for-horizontal-whitespace-s-h-t-blank-etc/8287/12
      replaced[0] = replaced[0].replace(/^[^\S\r\n\f]*\n/, '');
    const last = replaced.length-1;
    // Trim the last line if it has no content but there is content in the string
    const last_lines = replaced[last].split('\n');
    if (commonPrefix !== null || values.length) {
      if (!last_lines[last_lines.length - 1].trim()) {
        replaced[last] = replaced[last].replace(/\n[^\S\r\n\f]*$/, '');
      }
    }
    return intercalate.raw({ raw: replaced }, ...values);
  };

  Ve.scripty = (source, ...values) =>
    Ve.dedent(source, ...values.map(v => `(${JSON.stringify(v)})`));

  // Some helpers for escaping strings into various languages
  Ve.escape = {
    HTML: s => s
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;'),
    CSS: s => CSS.escape(s),
    JS: s => JSON.stringify(s),
    JSON: s => JSON.stringify(s),
    // https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript#30851002
    // see also: https://github.com/tc39/proposal-regex-escaping?tab=readme-ov-file#polyfills
    RegExp: Object.assign(
      s => s.replace(/[-\[\]{}()*+!<=:?.\/\\^$|#\s,]/g, '\\$&'),
      // Might add more specialized versions later
      {
      }
    ),
  };

  //////////////////////////////////////////////////////////////////////////////
  // Verbal Expressions! A classic way of constructing and composing regexes  //
  // using combinators, now brought to you by the magic of template literals. //
  //////////////////////////////////////////////////////////////////////////////

  // Template literals, where the interpolated regexes are sequenced (and
  // interpolated strings are converted to literal regexes, interpolated arrays
  // are considered alternative options).
  //
  // Might add some syntax, at least for assignments, to it, but not right now,
  // so currently the literal strings in between the interpolations are just
  // ignored. In any case, it will give good space for comments and whitespace.
  Ve.VerbExp = (_, ...values) => Ve.VerbExp.scoped(({ defined }) => {
    let flags = "";
    let source = "";
    for (let value of values) {
      if (!value) continue;
      let limit = 10;
      while (limit-- && typeof value === 'function')
        value = value();

      // Interpolated arrays give alternatives
      if (value instanceof Array) {
        value = Ve.VerbExp.alt(...value.map(Ve.VerbExp.coe));
      }

      if (value instanceof Error) throw value;

      if (typeof value === 'string' || value instanceof String) {
        // Interpolated strings are escaped, so they are literal values
        source += Ve.escape.RegExp(String(value));
      } else if (value instanceof RegExp) {
        // Regexes are sequenced (concatenated after wrapping in a non-capturing
        // group as necessary)
        if (value.source === Ve.VerbExp.always.source) continue;
        source += Ve.VerbExp.wrap.seq(value).source;
        flags += value.flags;
      }
    }
    // … there is nothing really good to do with flags other than to take
    // their union, heh
    flags = Ve.VerbExp.flags(flags);
    return Object.assign(new RegExp(source, flags), {defs: defined, [Ve.VerbExp.needsWrap.$]: 2});
  });
  Ve.VerbExp.raw = (...args) => String.raw(...args);


  // Save and restore `Ve.VerbExp.defined` while running `fn`
  Ve.VerbExp.scoped = fn => {
    const previous = Ve.VerbExp.defined;
    const defined = Ve.VerbExp.defined = Object.create(previous);
    const ret = fn({ VX: Ve.VerbExp, ...Ve.VerbExp, defined });
    for (const k of Object.keys(defined).reverse()) {
      if (!Object.hasOwn(defined, k)) continue;
      const v = defined[k];
      if (typeof v === 'function') {
        defined[k] = () => { throw new Error("Recursive definition of " + v) };
        defined[k] = v();
      }
    }
    Ve.VerbExp.defined = previous;
    return ret;
  };

  // just in case anyone would typo it (dunno who that would be ...)
  Ve.VerbExpr = Ve.VerbExp;

  // (reverse of normal precedence)
  // 0: atom
  // 1: postfix repetition operators
  // 2: sequence
  // 3: alternatives
  Ve.VerbExp.prec = Object.assign(['atom', 'postfix', 'seq', 'alt']);

  Ve.VerbExp.lit = lit => new RegExp(Ve.escape.RegExp(String(lit)));
  Ve.VerbExp.coe = re => {
    let limit = 10;
    while (limit-- && typeof re === 'function')
      re = re();
    if (typeof re === 'string' || re instanceof String)
      re = Ve.VerbExp.lit(re);
    if (!(re instanceof RegExp)) {
      if (re instanceof Error) throw re;
      throw new Error("Expected RegExp, got " + re);
    }
    return re;
  };
  Ve.VerbExp.src = re => Ve.VerbExp.coe(re).source;
  Ve.VerbExp.flags = flags => Array.from(new Set(flags)).join('');

  // A space for definitions
  Ve.VerbExp.defined = {};
  Ve.VerbExp.defs = new Proxy(Ve.VerbExp.defined, {
    get(_, name) {
      if (name in Ve.VerbExp.defined) return Ve.VerbExp.defined[name];
      return Object.assign(
        () => Ve.VerbExp.defined[name] ?? new Error("Ve.VerbExp.defs does not include " + name),
        { pending: name },
      );
    },
    set(_, name, value) {
      Ve.VerbExp.defined[name] = value;
      return true;
    },
  });

  // Helpers for the combinators
  Ve.VerbExp.withDef = f => sugarArg(named => {
    if (named) {
      const re = Ve.VerbExp.defs[named];
      if (!re) throw new Error("Ve.VerbExp.defs does not include " + name);
      return typeof re === 'function' ? (...args) => f(re(...args)) : f(re);
    } else return (...args) => {
      if (args.length && args[0] instanceof Array && 'raw' in args[0])
        args = [Ve.VerbExp(...args)];
      if (args.length && args.every(arg => typeof arg === 'function'))
        return (...argz) => f(Ve.VerbExp.alt(...args.map(f => f(...argz))));
      return f(Ve.VerbExp.alt(...args));
    }
  });
  Ve.VerbExp.withWrapped = sugarArg(expected => f => Ve.VerbExp.withDef(re => {
    return f(Ve.VerbExp.needsWrap(re, expected) ? `(?:${re.source})` : re.source);
  }));
  Ve.VerbExp.overSource = f => Ve.VerbExp.withDef(re => {
    const r = f(re.source);
    if (r !== re.source) return new RegExp(f(re.source), re.flags);
    return re;
  });
  Ve.VerbExp.overWrapped = sugarArg(expected => f => Ve.VerbExp.withDef(re => {
    const r = f(Ve.VerbExp.needsWrap(re, expected) ? `(?:${re.source})` : re.source);
    if (r !== re.source) return new RegExp(r, re.flags);
    return re;
  }));

  // Combinators
  Ve.VerbExp.always = /(?:)/; // always match
  Ve.VerbExp.never = /(?!)/; // never match
  // Turn a regex into a capturing group
  Ve.VerbExp.capture = Ve.VerbExp.withDef(re =>
    Ve.VerbExp.known(new RegExp(`(${re.source})`, re.flags), 0)
  );
  // (Unsafe) Never wrap this regex in parens (it is an atom)
  Ve.VerbExp.nowrap = Ve.VerbExp.withDef(re =>
    Ve.VerbExp.known(new RegExp(re.source, re.flags), 0)
  );
  // (Unsafe) Specify the precedence of the regex source
  Ve.VerbExp.known = (re, prec) => Object.assign(re, {[Ve.VerbExp.needsWrap.$]: prec});
  // Wrap a regex in a non-capturing group if necessary
  Ve.VerbExp.wrap = sugarArg(expected => Ve.VerbExp.overWrapped[expected](source => source));
  // Match zero or more times (`*`)
  Ve.VerbExp.star = Ve.VerbExp.overWrapped.postfix(source => source+'*');
  // Match one or more times (`+`)
  Ve.VerbExp.plus = Ve.VerbExp.overWrapped.postfix(source => source+'+');
  // Match zero or one time (`?`)
  Ve.VerbExp.opt = Ve.VerbExp.overWrapped.postfix(source => source+'?');
  // Repeat `n,m` times. `repeat[[1,25]]` or `repeat(1,25)` or `repeat[3]`
  Ve.VerbExp.repeat = sugarStr((...bounds) => Ve.VerbExp.overWrapped.postfix(source => {
    if (bounds === '+' || bounds === '*') return source+bounds;
    if (bounds === '0' || bounds === 0) return '(?:)';
    if (bounds === '1' || bounds === 1) return source;
    bounds = String(bounds);
    return source+'{'+bounds+'}';
  }));
  // A list of alternative regexes to match
  Ve.VerbExp.alt = (...items) => {
    const regexes = items.map(Ve.VerbExp.coe);
    const flags = Ve.VerbExp.flags(items.map(_.flags));
    const filtered = regexes.filter(({source}) => source !== Ve.VerbExp.never.source);
    if (!filtered.length) return Ve.VerbExp.never;
    if (filtered.length === 1) return items[0];
    const re = new RegExp(filtered.map(_.source).join('|'), flags);
    re[Ve.VerbExp.needsWrap.$] = 3;
    return re;
  };
  // A list of regexes to match in sequence
  Ve.VerbExp.seq = (...items) => {
    const regexes = items.map(Ve.VerbExp.coe);
    const flags = Ve.VerbExp.flags(items.map(_.flags));
    const filtered = regexes.filter(({source}) => source !== Ve.VerbExp.always.source);
    if (!filtered.length) return Ve.VerbExp.always;
    if (filtered.length === 1) return items[0];
    // TODO: escape boundaries of like escape sequences and such
    const re = new RegExp(filtered.map(Ve.VerbExp.wrap.seq).map(_.source).join(''), flags);
    re[Ve.VerbExp.needsWrap.$] = 2;
    return re;
  };

  // Guess what the precedence of `re.source` is (an over-approximation),
  // so that we know if we need to wrap it in a non-capturing group
  Ve.VerbExp.needsWrap = (re, expected) => {
    let NEEDSWRAP = Ve.VerbExp.needsWrap.$;
    let level = 0;
    let charcls = false;
    let i = 0;
    let escape = false;
    let ret = 0;
    if (re instanceof RegExp && NEEDSWRAP in re) {
      ret = re[NEEDSWRAP];
    } else {
      const str = re instanceof RegExp ? re.source : String(re);
      if (!str.match(/^[\w\s]+$/) && !str.match(/^\[[^\]]+\]$/)) {
        if (str.length > 1 && (str.length > 2 || source[0] !== '\\'))
          ret = 2;
      }
      const source = Array.from(str);
      const handlers = {
        ['\\']() { escape = true },
        ['[']() { charcls = true },
        [']']() { charcls = false },
        ['(']() { if (!charcls) level += 1 },
        [')']() { if (!charcls) level -= 1 },
        ['|']() { if (!charcls && !level) ret = 3 },
      };
      for (let char of source) {
        if (!escape) {
          handlers[char]?.();
          if (ret === 3) break;
        } else escape = false;
        i += 1;
      }
      if (re instanceof RegExp) re[NEEDSWRAP] = ret;
    }
    if (expected === 'undefined') expected=undefined;
    if (expected) {
      if (expected in Ve.VerbExp.prec)
        expected = Ve.VerbExp.prec[expected];
      if (Ve.VerbExp.prec.includes(expected))
        expected = Ve.VerbExp.prec.indexOf(expected);
      if (typeof expected !== 'number')
        throw new Error('Unknown precedence ' + expected);
      return expected < ret;
    }
    return ret;
  };
  Ve.VerbExp.needsWrap.$ = Symbol("needsWrap");

  //////////////////////////////////////////////////////////////////////////////

  // Named capturing groups are still recent (2024)...
  Ve.dataURI = Ve.VerbExp.scoped(({ defs, VX, defined: _defined }) => {
    // https://datatracker.ietf.org/doc/html/rfc6838#section-4.2
    ` type-name = restricted-name
      subtype-name = restricted-name
    `
    defs.type_name = VX.capture.restricted_name; // automatic forward reference
    defs.subtype_name = VX.capture.restricted_name;
    ` restricted-name = restricted-name-first *126restricted-name-chars
      restricted-name-first  = ALPHA / DIGIT
      restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
                              "$" / "&" / "-" / "^" / "_"
      restricted-name-chars =/ "." ; Characters before first dot always
                                  ; specify a facet name
      restricted-name-chars =/ "+" ; Characters after last plus always
                                  ; specify a structured syntax suffix
    `
    defs.restricted_name_first = /[a-zA-Z0-9]/;
    defs.restricted_name_chars = /[-a-zA-Z0-9!#$&^_+.]/;
    defs.restricted_name = VX`
      // total length: 1-127 characters
      ${defs.restricted_name_first}
      ${VX.repeat[[0,126]].restricted_name_chars}
    `;

    // https://datatracker.ietf.org/doc/html/rfc6838#section-4.3
    // > It is an error for a specific parameter to be specified more than once.
    ` parameter-name = restricted-name `
    defs.parameter_name = defs.restricted_name;
    defs.attribute = defs.parameter_name; // different standards, different names

    // https://datatracker.ietf.org/doc/html/rfc2045#section-5.1
    ` content := "Content-Type" ":" type "/" subtype
            *(";" parameter)
            ; Matching of media type and subtype
            ; is ALWAYS case-insensitive.
    `
    defs.parameters = () => VX.star`${";"}${defs.parameter}`; // the template literals
    // defs.mime = VX.capture`${defs.type}${"/"}${defs.subtype}`;
    ` parameter := attribute "=" value `
    defs.parameter = () => VX`${defs.attribute}${"="}${defs.value}`;
    ` value := token / quoted-string `
    defs.value = () => VX.alt(defs.token, defs.quoted_string);
    ` token := 1*<any (US-ASCII) CHAR except SPACE, CTLs,
                  or tspecials>
      tspecials :=  "(" / ")" / "<" / ">" / "@" /
                    "," / ";" / ":" / "\" / <">
                    "/" / "[" / "]" / "?" / "="
                    ; Must be in quoted-string,
                    ; to use within parameter values
    `
    defs.token = /[-a-zA-Z0-9!#$&^_+.]+/; // '%| ???
    // https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6
    ` quoted-string := ${/"(?:[\t \x21\x23-\x5B\x5D-\x7E\x80-\xFF]|\\[\t \x21-\x7E\x80-\xFF])*"/}
      quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
      qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
      obs-text       = %x80-FF
      quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )
    `
    defs.qdtext = /[\t \x21\x23-\x5B\x5D-\x7E\x80-\xFF]/;
    defs.quoted_pair = /\\[\t \x21-\x7E\x80-\xFF]/;
    defs.quoted_string = VX`${'"'} ${VX.star(defs.qdtext, defs.quoted_pair)} ${'"'}`;

    defs.dataURI = VX`
      ${/^data:/}
      ${VX.capture`${defs.type_name()} ${"/"} ${defs.subtype_name()}`}
      ${VX.capture.parameters}
      ${VX.opt(VX.capture(/;base64/))}
      ${","}
    `;

    const reference = /^data:(([a-zA-Z0-9][-a-zA-Z0-9!#$&^_+.]{0,126})\/([a-zA-Z0-9][-a-zA-Z0-9!#$&^_+.]{0,126}))((?:;[a-zA-Z0-9][-a-zA-Z0-9!#$&^_+.]{0,126}\=(?:[-a-zA-Z0-9!#$&^_+.]+|"(?:[\t \x21\x23-\x5B\x5D-\x7E\x80-\xFF]|\\[\t \x21-\x7E\x80-\xFF])*"))*)(;base64)?\,/;
    if (defs.dataURI.source != reference.source) {
      console.error('Discrepancy:', defs.dataURI, reference);
    }

    return Object.assign(defs.dataURI, { defs: VX.defined });
  });

  Ve.fromDataURI = function fromDataURI(uri) {
    let match = Ve.dataURI.exec(uri);
    if (!match) throw new Error("Invalid data URI", uri);
    let parameters = match[4].substring(1).split(";");
    parameters = parameters.filter(Boolean).map(parameter => {
      let [attribute, value] = parameter.split("=", 2);
      attribute = attribute.toLowerCase();
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.substring(1, value.length-1)
          .replaceAll(/\\([\t \x21-\x7E\x80-\xFF])/g, '$1');
      }
      return [attribute, value];
    });
    parameters = Object.fromEntries(parameters);
    const base64 = !!match[5];
    const encoded = uri.substring(match[0].length);
    let data = undefined;
    let text = undefined;
    const extra = Object.assign({}, [
      match[2] === 'text' && { charset: parameters['charset'] || 'UTF-8' },
    ].filter(o=>typeof o === 'object'));
    return {
      ...extra,
      mime: match[1].toLowerCase(),
      type: match[2].toLowerCase(),
      subtype: match[3].toLowerCase(),
      parameters: parameters,
      base64,
      encoded,
      get data() {
        if (data === undefined) {
          data = base64
            ? fromB64.bytes(encoded)
            // hmm, binary URI encoded??
            : (new TextEncoder()).encode(decodeURI(encoded));
        }
        return data;
      },
      get text() {
        if (text === undefined) {
          text =
            base64
              ? data !== undefined
                ? (new TextDecoder(extra.charset)).decode(data)
                : fromB64.text(encoded, extra.charset)
              : decodeURI(encoded);
        }
        return text;
      },
    }
  };

  //////////////////////////////////////////////////////////////////////////////

  return this;
}).call(Verity);
</script><script>"use strict";
function listenForUploads(onFiles) {
  const { file_upload, compose } = Ve.ById;

  const PLACEHOLDER = 'Upload! (escape to cancel)';
  let last_placeholder;

  const cleanup = mkCleanup();

  async function obtainFiles(theFiles) {
    theFiles = Array.from(theFiles);
    if (!theFiles.length) return;
    return await Promise.all(theFiles.map(async f => [f, await readFile(f)]));
  }
  async function addFiles(theFiles) {
    onFiles(await obtainFiles(theFiles));
  }

  async function pasteData(items) {
    const files = [];
    for (const item of items) {
      if (item.kind === 'file') {
        files.push(item.getAsFile());
      } else if (item.kind === 'string' && item.type === 'text/plain') {
        if (!["input","textarea"].includes(event.target.localName)) {
          item.getAsString(value => {
            // TODO: TextCursor
            compose.value = value;
            compose.focus();
          });
        }
      }
    }
    if (files.length) addFiles(files);
  }

  cleanup(
    // Global paste, which includes strings (which become composed messages) and files
    document.on.paste(event => {
      pasteData(event.clipboardData.items);
    }),
    // Global drag and drop (e.g. from OS)
    document.on.dragover(event => {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'copy';
      if (compose.placeholder != PLACEHOLDER) last_placeholder = compose.placeholder;
      compose.placeholder = PLACEHOLDER;
    }),
    document.on.drop(event => {
      event.preventDefault();
      // Go through with the drop, adding all of the items
      compose.placeholder = last_placeholder ?? '';
      pasteData(event.dataTransfer.items);
    }),
    document.on.dragleave(function() {
      // Cancel the drag
      compose.placeholder = last_placeholder ?? '';
    }),

    file_upload.on.change(() => {
      addFiles(file_upload.files);
      file_upload.value = ''; // clear it
    }),
  );
  file_upload.disabled = false;

  return cleanup;
}
</script><script>// https://source.chromium.org/chromium/chromium/src/+/main:net/base/mime_util.cc;l=675-743;drc=482a810cb3635f84e6a9e74b6a64ecbe7acaa897

const kStandardImageTypes = [
  "image/avif",
  "image/bmp",
  "image/cis-cod",
  "image/gif",
  "image/heic",
  "image/heif",
  "image/ief",
  "image/jpeg",
  "image/webp",
  "image/pict",
  "image/pipeg",
  "image/png",
  "image/svg+xml",
  "image/tiff",
  "image/vnd.microsoft.icon",
  "image/x-cmu-raster",
  "image/x-cmx",
  "image/x-icon",
  "image/x-portable-anymap",
  "image/x-portable-bitmap",
  "image/x-portable-graymap",
  "image/x-portable-pixmap",
  "image/x-rgb",
  "image/x-xbitmap",
  "image/x-xpixmap",
  "image/x-xwindowdump",
];
const kStandardAudioTypes = [
  "audio/aac",
  "audio/aiff",
  "audio/amr",
  "audio/basic",
  "audio/flac",
  "audio/midi",
  "audio/mp3",
  "audio/mp4",
  "audio/mpeg",
  "audio/mpeg3",
  "audio/ogg",
  "audio/vorbis",
  "audio/wav",
  "audio/webm",
  "audio/x-m4a",
  "audio/x-ms-wma",
  "audio/vnd.rn-realaudio",
  "audio/vnd.wave",
];
// https://tools.ietf.org/html/rfc8081
const kStandardFontTypes = [
  "font/collection", "font/otf",  "font/sfnt",
  "font/ttf",        "font/woff", "font/woff2",
];
const kStandardVideoTypes = [
  "video/avi",
  "video/divx",
  "video/flc",
  "video/mp4",
  "video/mpeg",
  "video/ogg",
  "video/quicktime",
  "video/sd-video",
  "video/webm",
  "video/x-dv",
  "video/x-m4v",
  "video/x-mpeg",
  "video/x-ms-asf",
  "video/x-ms-wmv",
];
const kStandardTypes = Object.assign([
  ...kStandardImageTypes,
  ...kStandardAudioTypes,
  ...kStandardFontTypes,
  ...kStandardVideoTypes,
], {
  "image": kStandardImageTypes,
  "audio": kStandardAudioTypes,
  "font": kStandardFontTypes,
  "video": kStandardVideoTypes,
});
</script><script>"use strict";
function host_ui({ rtc }) {
  host_ui.cleanup();
  const cleanup = host_ui.cleanup;

  if (Ve.ById.compose) {
    const compose = Ve.ById.compose;
    const localCleanup = mkCleanup();
    cleanup(localCleanup);
    localCleanup(
      compose.on.keyup(async ev => {
        if (!rtc || rtc.signalingState === 'stable') return localCleanup();
        if (ev.key === 'Enter') {
          const value = compose.value.replaceAll('\u2588', '').trim();
          if (/\w+/.exec(value)[0] === 'upload') {
            compose.value = "";
            Ve.ById.file_upload.click();
          } else if (value) {
            await host.setUFrag(value);
            compose.value = "";
          }
        }
      }),
      compose.on.input(async ev => {
        if (!rtc || rtc.signalingState === 'stable') return localCleanup();
        const value = compose.value.replaceAll('\u2588', '').trim();
        if (value.match(RE_FINGERPRINT)) {
          await host.setUFrag(value);
          compose.value = "";
        }
      }),
    );
  }

  window.ZXing && cleanup(host_ui.uploadQR());

  return cleanup;
}
Object.assign(host_ui, {
  cleanup: mkCleanup(),
  logMessage(classes, summary, content) {
    const { HTML } = Ve;

    summary = [summary, ' ', Ve.applyProps(showTime(), {style:{float:'right'}})];
    const element = HTML.div({ classList: classes }, [
      content ? HTML.details(HTML.summary(summary), content) : summary,
    ]);
    Ve.ById.chat_content.appendChild(element);
    host_ui.cleanup(() => element.removeSelf());
  },
  logStatus(summary, content) {
    host_ui.logMessage(['message', 'ephemeral', 'echo', 'full-width'], summary, content);
  },
  logEvent(summary, content) {
    host_ui.logMessage(['message', 'ephemeral', 'event'], summary, content);
  },
  logError(e) {
    const { HTML } = Ve;

    let summary = String(e);
    let content = renderJSON(e);
    if (e instanceof window.ZXing?.Exception) {
      summary = ['ZXing: ', e.getKind(), ': ', e.message];
    }
    if (e instanceof Error) {
      // summary = e.message;
      content = [content, HTML.pre(e.stack)];
    }
    host_ui.logMessage(['message', 'ephemeral', 'echo', 'full-width'], summary, content);
    console.error(e);
  },
  throwError(e) {
    host_ui.logError(e);
    throw e;
  },
  logRemoteError(e) {
    const { HTML } = Ve;

    let summary = String(e);
    let content = renderJSON(e);
    if (e instanceof Error) {
      // summary = e.message;
      content = [content, HTML.pre(e.stack)];
    }
    host_ui.logMessage(['message', 'ephemeral', 'peer', 'full-width'], summary, content);
    console.error(e);
  },


  onQR(result) {
    console.log(result);
    assert(result.format === 11);
    assert(result.numBits === 272);
    assert(result.rawBytes[0] === 0x42);
    const fingerprint = Array.from(result.rawBytes, b=>b.toString(16).padStart(2,0)).join('').slice(3, -1);
    assert(RE_FINGERPRINT.test(fingerprint));
    host.setUFrag(fingerprint);
  },

  async scanQR(cb) {
    if (!window.ZXing?.BrowserQRCodeReader) return;
    if (!window.isSecureContext) return;

    if (!cb) cb = async result => {await host_ui.onQR(result); cancel()};

    const cancel = () => {select.value = selectedDeviceId = noDevice; restart()};

    // decode every second
    const codeReader = new window.ZXing.BrowserQRCodeReader(undefined, 1000);

    const div = Ve.ById.from_guest.appendChild(Ve.HTML.div());
    let video;
    function newVideo() {
      video = div.appendChild(
        Ve.HTML.video({ width: 300, height: 200, style: {...Ve.styl.marginAuto, display:'block'}})
      );
    }

    const videoInputDevices = await codeReader.getVideoInputDevices();
    const noDevice = '[Not Scanning]';
    let selectedDeviceId = noDevice;//videoInputDevices[0].deviceId;
    function restart() {
      codeReader.reset();
      if (selectedDeviceId === noDevice) {
        if (video) { video.removeSelf(); video = undefined; }
        return;
      }
      if (!video) newVideo();
      // console.log(video, video.parentElement, video.getRootNode(), [...videoParent.children]);
      // console.log(selectedDeviceId);
      // .getSettings().facingMode
      codeReader.decodeFromInputVideoDeviceContinuously(selectedDeviceId, video, async (result, err) => {
        if (!video || !video.parentElement || video.getRootNode() !== document) {
          console.log("Video removed, stopping QR scanning", err?.constructor.kind);
          codeReader.reset();
          select.value = selectedDeviceId = noDevice;
          // console.log(video, video && { parentElement: video.parentElement, rootNode: video.getRootNode() });
        }
        if (!result) return;
        try {
          await cb(result);
        } catch(err) {
          host_ui.logError(err);
        }
        codeReader.reset();
      });
      console.log("Starting QR scanning with device ID", selectedDeviceId);
    }
    const select = Ve.HTML.select(
      {
        style: { ...Ve.styl.marginAuto, display: 'block' },
        onchange: e => {
          if (e.target.value === noDevice) {
            selectedDeviceId = noDevice;
          } else {
            selectedDeviceId = videoInputDevices[e.target.value]
              ? videoInputDevices[e.target.value].deviceId : e.target.value;
          }
          restart();
        },
      },
      Ve.HTML.option({ text: '[Not Scanning]', value: noDevice }),
      videoInputDevices.map((dev, idx) =>
        Ve.HTML.option({ text: dev.label, value: dev.deviceId || idx })
      ),
    );
    div.appendChild(select);
    restart();
    host_ui.cleanup(div, cancel);
    return div;
  },

  uploadQR(cb) {
    if (!cb) cb = result => host_ui.onQR(result);
    return listenForUploads(async files => {
      const reader = new window.ZXing.BrowserQRCodeReader();
      for (const [file, src] of files) {
        try {
          console.log(file);
          if (!file.type.startsWith('image/')) continue;
          const result = await reader.decodeFromImageUrl(src);
          if (!result) continue;
          await cb(result);
        } catch(err) {
          host_ui.logError(err);
        }
      }
    })
  },
});
</script><script>/*
 * Copyright 2014 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).ZXing={})}(this,(function(t){"use strict";var e,r,n=(e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])},e(t,r)},function(t,r){if("function"!=typeof r&&null!==r)throw new TypeError("Class extends value "+String(r)+" is not a constructor or null");function n(){this.constructor=t}e(t,r),t.prototype=null===r?Object.create(r):(n.prototype=r.prototype,new n)}),i=function(t){function e(e,r){var n,i,s,o=this.constructor,a=t.call(this,e,r)||this;return Object.defineProperty(a,"name",{value:o.name,enumerable:!1,configurable:!0}),n=a,i=o.prototype,(s=Object.setPrototypeOf)?s(n,i):n.__proto__=i,function(t,e){void 0===e&&(e=t.constructor);var r=Error.captureStackTrace;r&&r(t,e)}(a),a}return n(e,t),e}(Error);class s extends i{constructor(t=void 0){super(t),this.message=t}getKind(){return this.constructor.kind}}s.kind="Exception";class o extends s{}o.kind="ArgumentException";class a extends s{}a.kind="IllegalArgumentException";class h{constructor(t){if(this.binarizer=t,null===t)throw new a("Binarizer must be non-null.")}getWidth(){return this.binarizer.getWidth()}getHeight(){return this.binarizer.getHeight()}getBlackRow(t,e){return this.binarizer.getBlackRow(t,e)}getBlackMatrix(){return null!==this.matrix&&void 0!==this.matrix||(this.matrix=this.binarizer.getBlackMatrix()),this.matrix}isCropSupported(){return this.binarizer.getLuminanceSource().isCropSupported()}crop(t,e,r,n){const i=this.binarizer.getLuminanceSource().crop(t,e,r,n);return new h(this.binarizer.createBinarizer(i))}isRotateSupported(){return this.binarizer.getLuminanceSource().isRotateSupported()}rotateCounterClockwise(){const t=this.binarizer.getLuminanceSource().rotateCounterClockwise();return new h(this.binarizer.createBinarizer(t))}rotateCounterClockwise45(){const t=this.binarizer.getLuminanceSource().rotateCounterClockwise45();return new h(this.binarizer.createBinarizer(t))}toString(){try{return this.getBlackMatrix().toString()}catch(t){return""}}}class l extends s{static getChecksumInstance(){return new l}}l.kind="ChecksumException";class c{constructor(t){this.source=t}getLuminanceSource(){return this.source}getWidth(){return this.source.getWidth()}getHeight(){return this.source.getHeight()}}class d{static arraycopy(t,e,r,n,i){if(t===r&&e<n)for(n+=i-1,e+=i-1;i--;)r[n--]=t[e--];else for(;i--;)r[n++]=t[e++]}static currentTimeMillis(){return Date.now()}}class u extends s{}u.kind="IndexOutOfBoundsException";class f extends u{constructor(t=void 0,e=void 0){super(e),this.index=t,this.message=e}}f.kind="ArrayIndexOutOfBoundsException";class w{static fill(t,e){for(let r=0,n=t.length;r<n;r++)t[r]=e}static fillWithin(t,e,r,n){w.rangeCheck(t.length,e,r);for(let i=e;i<r;i++)t[i]=n}static rangeCheck(t,e,r){if(e>r)throw new a("fromIndex("+e+") > toIndex("+r+")");if(e<0)throw new f(e);if(r>t)throw new f(r)}static asList(...t){return t}static create(t,e,r){return Array.from({length:t}).map((t=>Array.from({length:e}).fill(r)))}static createInt32Array(t,e,r){return Array.from({length:t}).map((t=>Int32Array.from({length:e}).fill(r)))}static equals(t,e){if(!t)return!1;if(!e)return!1;if(!t.length)return!1;if(!e.length)return!1;if(t.length!==e.length)return!1;for(let r=0,n=t.length;r<n;r++)if(t[r]!==e[r])return!1;return!0}static hashCode(t){if(null===t)return 0;let e=1;for(const r of t)e=31*e+r;return e}static fillUint8Array(t,e){for(let r=0;r!==t.length;r++)t[r]=e}static copyOf(t,e){return t.slice(0,e)}static copyOfUint8Array(t,e){if(t.length<=e){const r=new Uint8Array(e);return r.set(t),r}return t.slice(0,e)}static copyOfRange(t,e,r){const n=r-e,i=new Int32Array(n);return d.arraycopy(t,e,i,0,n),i}static binarySearch(t,e,r){void 0===r&&(r=w.numberComparator);let n=0,i=t.length-1;for(;n<=i;){const s=i+n>>1,o=r(e,t[s]);if(o>0)n=s+1;else{if(!(o<0))return s;i=s-1}}return-n-1}static numberComparator(t,e){return t-e}}class g{static numberOfTrailingZeros(t){let e;if(0===t)return 32;let r=31;return e=t<<16,0!==e&&(r-=16,t=e),e=t<<8,0!==e&&(r-=8,t=e),e=t<<4,0!==e&&(r-=4,t=e),e=t<<2,0!==e&&(r-=2,t=e),r-(t<<1>>>31)}static numberOfLeadingZeros(t){if(0===t)return 32;let e=1;return t>>>16==0&&(e+=16,t<<=16),t>>>24==0&&(e+=8,t<<=8),t>>>28==0&&(e+=4,t<<=4),t>>>30==0&&(e+=2,t<<=2),e-=t>>>31,e}static toHexString(t){return t.toString(16)}static toBinaryString(t){return String(parseInt(String(t),2))}static bitCount(t){return t=(t=(858993459&(t-=t>>>1&1431655765))+(t>>>2&858993459))+(t>>>4)&252645135,t+=t>>>8,63&(t+=t>>>16)}static truncDivision(t,e){return Math.trunc(t/e)}static parseInt(t,e=void 0){return parseInt(t,e)}}g.MIN_VALUE_32_BITS=-2147483648,g.MAX_VALUE=Number.MAX_SAFE_INTEGER;class m{constructor(t,e){void 0===t?(this.size=0,this.bits=new Int32Array(1)):(this.size=t,this.bits=null==e?m.makeArray(t):e)}getSize(){return this.size}getSizeInBytes(){return Math.floor((this.size+7)/8)}ensureCapacity(t){if(t>32*this.bits.length){const e=m.makeArray(t);d.arraycopy(this.bits,0,e,0,this.bits.length),this.bits=e}}get(t){return!!(this.bits[Math.floor(t/32)]&1<<(31&t))}set(t){this.bits[Math.floor(t/32)]|=1<<(31&t)}flip(t){this.bits[Math.floor(t/32)]^=1<<(31&t)}getNextSet(t){const e=this.size;if(t>=e)return e;const r=this.bits;let n=Math.floor(t/32),i=r[n];i&=~((1<<(31&t))-1);const s=r.length;for(;0===i;){if(++n===s)return e;i=r[n]}const o=32*n+g.numberOfTrailingZeros(i);return o>e?e:o}getNextUnset(t){const e=this.size;if(t>=e)return e;const r=this.bits;let n=Math.floor(t/32),i=~r[n];i&=~((1<<(31&t))-1);const s=r.length;for(;0===i;){if(++n===s)return e;i=~r[n]}const o=32*n+g.numberOfTrailingZeros(i);return o>e?e:o}setBulk(t,e){this.bits[Math.floor(t/32)]=e}setRange(t,e){if(e<t||t<0||e>this.size)throw new a;if(e===t)return;e--;const r=Math.floor(t/32),n=Math.floor(e/32),i=this.bits;for(let s=r;s<=n;s++){const o=(2<<(s<n?31:31&e))-(1<<(s>r?0:31&t));i[s]|=o}}clear(){const t=this.bits.length,e=this.bits;for(let r=0;r<t;r++)e[r]=0}isRange(t,e,r){if(e<t||t<0||e>this.size)throw new a;if(e===t)return!0;e--;const n=Math.floor(t/32),i=Math.floor(e/32),s=this.bits;for(let o=n;o<=i;o++){const a=(2<<(o<i?31:31&e))-(1<<(o>n?0:31&t))&4294967295;if((s[o]&a)!==(r?a:0))return!1}return!0}appendBit(t){this.ensureCapacity(this.size+1),t&&(this.bits[Math.floor(this.size/32)]|=1<<(31&this.size)),this.size++}appendBits(t,e){if(e<0||e>32)throw new a("Num bits must be between 0 and 32");this.ensureCapacity(this.size+e);for(let r=e;r>0;r--)this.appendBit(1==(t>>r-1&1))}appendBitArray(t){const e=t.size;this.ensureCapacity(this.size+e);for(let r=0;r<e;r++)this.appendBit(t.get(r))}xor(t){if(this.size!==t.size)throw new a("Sizes don't match");const e=this.bits;for(let r=0,n=e.length;r<n;r++)e[r]^=t.bits[r]}toBytes(t,e,r,n){for(let i=0;i<n;i++){let n=0;for(let e=0;e<8;e++)this.get(t)&&(n|=1<<7-e),t++;e[r+i]=n}}getBitArray(){return this.bits}reverse(){const t=new Int32Array(this.bits.length),e=Math.floor((this.size-1)/32),r=e+1,n=this.bits;for(let i=0;i<r;i++){let r=n[i];r=r>>1&1431655765|(1431655765&r)<<1,r=r>>2&858993459|(858993459&r)<<2,r=r>>4&252645135|(252645135&r)<<4,r=r>>8&16711935|(16711935&r)<<8,r=r>>16&65535|(65535&r)<<16,t[e-i]=r}if(this.size!==32*r){const e=32*r-this.size;let n=t[0]>>>e;for(let i=1;i<r;i++){const r=t[i];n|=r<<32-e,t[i-1]=n,n=r>>>e}t[r-1]=n}this.bits=t}static makeArray(t){return new Int32Array(Math.floor((t+31)/32))}equals(t){if(!(t instanceof m))return!1;const e=t;return this.size===e.size&&w.equals(this.bits,e.bits)}hashCode(){return 31*this.size+w.hashCode(this.bits)}toString(){let t="";for(let e=0,r=this.size;e<r;e++)7&e||(t+=" "),t+=this.get(e)?"X":".";return t}clone(){return new m(this.size,this.bits.slice())}toArray(){let t=[];for(let e=0,r=this.size;e<r;e++)t.push(this.get(e));return t}}!function(t){t[t.OTHER=0]="OTHER",t[t.PURE_BARCODE=1]="PURE_BARCODE",t[t.POSSIBLE_FORMATS=2]="POSSIBLE_FORMATS",t[t.TRY_HARDER=3]="TRY_HARDER",t[t.CHARACTER_SET=4]="CHARACTER_SET",t[t.ALLOWED_LENGTHS=5]="ALLOWED_LENGTHS",t[t.ASSUME_CODE_39_CHECK_DIGIT=6]="ASSUME_CODE_39_CHECK_DIGIT",t[t.ENABLE_CODE_39_EXTENDED_MODE=7]="ENABLE_CODE_39_EXTENDED_MODE",t[t.ASSUME_GS1=8]="ASSUME_GS1",t[t.RETURN_CODABAR_START_END=9]="RETURN_CODABAR_START_END",t[t.NEED_RESULT_POINT_CALLBACK=10]="NEED_RESULT_POINT_CALLBACK",t[t.ALLOWED_EAN_EXTENSIONS=11]="ALLOWED_EAN_EXTENSIONS"}(r||(r={}));var I,A=r;class p extends s{static getFormatInstance(){return new p}}p.kind="FormatException",function(t){t[t.Cp437=0]="Cp437",t[t.ISO8859_1=1]="ISO8859_1",t[t.ISO8859_2=2]="ISO8859_2",t[t.ISO8859_3=3]="ISO8859_3",t[t.ISO8859_4=4]="ISO8859_4",t[t.ISO8859_5=5]="ISO8859_5",t[t.ISO8859_6=6]="ISO8859_6",t[t.ISO8859_7=7]="ISO8859_7",t[t.ISO8859_8=8]="ISO8859_8",t[t.ISO8859_9=9]="ISO8859_9",t[t.ISO8859_10=10]="ISO8859_10",t[t.ISO8859_11=11]="ISO8859_11",t[t.ISO8859_13=12]="ISO8859_13",t[t.ISO8859_14=13]="ISO8859_14",t[t.ISO8859_15=14]="ISO8859_15",t[t.ISO8859_16=15]="ISO8859_16",t[t.SJIS=16]="SJIS",t[t.Cp1250=17]="Cp1250",t[t.Cp1251=18]="Cp1251",t[t.Cp1252=19]="Cp1252",t[t.Cp1256=20]="Cp1256",t[t.UnicodeBigUnmarked=21]="UnicodeBigUnmarked",t[t.UTF8=22]="UTF8",t[t.ASCII=23]="ASCII",t[t.Big5=24]="Big5",t[t.GB18030=25]="GB18030",t[t.EUC_KR=26]="EUC_KR"}(I||(I={}));class E{constructor(t,e,r,...n){this.valueIdentifier=t,this.name=r,this.values="number"==typeof e?Int32Array.from([e]):e,this.otherEncodingNames=n,E.VALUE_IDENTIFIER_TO_ECI.set(t,this),E.NAME_TO_ECI.set(r,this);const i=this.values;for(let t=0,e=i.length;t!==e;t++){const e=i[t];E.VALUES_TO_ECI.set(e,this)}for(const t of n)E.NAME_TO_ECI.set(t,this)}getValueIdentifier(){return this.valueIdentifier}getName(){return this.name}getValue(){return this.values[0]}static getCharacterSetECIByValue(t){if(t<0||t>=900)throw new p("incorect value");const e=E.VALUES_TO_ECI.get(t);if(void 0===e)throw new p("incorect value");return e}static getCharacterSetECIByName(t){const e=E.NAME_TO_ECI.get(t);if(void 0===e)throw new p("incorect value");return e}equals(t){if(!(t instanceof E))return!1;const e=t;return this.getName()===e.getName()}}E.VALUE_IDENTIFIER_TO_ECI=new Map,E.VALUES_TO_ECI=new Map,E.NAME_TO_ECI=new Map,E.Cp437=new E(I.Cp437,Int32Array.from([0,2]),"Cp437"),E.ISO8859_1=new E(I.ISO8859_1,Int32Array.from([1,3]),"ISO-8859-1","ISO88591","ISO8859_1"),E.ISO8859_2=new E(I.ISO8859_2,4,"ISO-8859-2","ISO88592","ISO8859_2"),E.ISO8859_3=new E(I.ISO8859_3,5,"ISO-8859-3","ISO88593","ISO8859_3"),E.ISO8859_4=new E(I.ISO8859_4,6,"ISO-8859-4","ISO88594","ISO8859_4"),E.ISO8859_5=new E(I.ISO8859_5,7,"ISO-8859-5","ISO88595","ISO8859_5"),E.ISO8859_6=new E(I.ISO8859_6,8,"ISO-8859-6","ISO88596","ISO8859_6"),E.ISO8859_7=new E(I.ISO8859_7,9,"ISO-8859-7","ISO88597","ISO8859_7"),E.ISO8859_8=new E(I.ISO8859_8,10,"ISO-8859-8","ISO88598","ISO8859_8"),E.ISO8859_9=new E(I.ISO8859_9,11,"ISO-8859-9","ISO88599","ISO8859_9"),E.ISO8859_10=new E(I.ISO8859_10,12,"ISO-8859-10","ISO885910","ISO8859_10"),E.ISO8859_11=new E(I.ISO8859_11,13,"ISO-8859-11","ISO885911","ISO8859_11"),E.ISO8859_13=new E(I.ISO8859_13,15,"ISO-8859-13","ISO885913","ISO8859_13"),E.ISO8859_14=new E(I.ISO8859_14,16,"ISO-8859-14","ISO885914","ISO8859_14"),E.ISO8859_15=new E(I.ISO8859_15,17,"ISO-8859-15","ISO885915","ISO8859_15"),E.ISO8859_16=new E(I.ISO8859_16,18,"ISO-8859-16","ISO885916","ISO8859_16"),E.SJIS=new E(I.SJIS,20,"SJIS","Shift_JIS"),E.Cp1250=new E(I.Cp1250,21,"Cp1250","windows-1250"),E.Cp1251=new E(I.Cp1251,22,"Cp1251","windows-1251"),E.Cp1252=new E(I.Cp1252,23,"Cp1252","windows-1252"),E.Cp1256=new E(I.Cp1256,24,"Cp1256","windows-1256"),E.UnicodeBigUnmarked=new E(I.UnicodeBigUnmarked,25,"UnicodeBigUnmarked","UTF-16BE","UnicodeBig"),E.UTF8=new E(I.UTF8,26,"UTF8","UTF-8"),E.ASCII=new E(I.ASCII,Int32Array.from([27,170]),"ASCII","US-ASCII"),E.Big5=new E(I.Big5,28,"Big5"),E.GB18030=new E(I.GB18030,29,"GB18030","GB2312","EUC_CN","GBK"),E.EUC_KR=new E(I.EUC_KR,30,"EUC_KR","EUC-KR");class S extends s{}S.kind="UnsupportedOperationException";class C{static decode(t,e){const r=this.encodingName(e);return this.customDecoder?this.customDecoder(t,r):"undefined"==typeof TextDecoder||this.shouldDecodeOnFallback(r)?this.decodeFallback(t,r):new TextDecoder(r).decode(t)}static shouldDecodeOnFallback(t){return!C.isBrowser()&&"ISO-8859-1"===t}static encode(t,e){const r=this.encodingName(e);return this.customEncoder?this.customEncoder(t,r):"undefined"==typeof TextEncoder?this.encodeFallback(t):(new TextEncoder).encode(t)}static isBrowser(){return"undefined"!=typeof window&&"[object Window]"==={}.toString.call(window)}static encodingName(t){return"string"==typeof t?t:t.getName()}static encodingCharacterSet(t){return t instanceof E?t:E.getCharacterSetECIByName(t)}static decodeFallback(t,e){const r=this.encodingCharacterSet(e);if(C.isDecodeFallbackSupported(r)){let e="";for(let r=0,n=t.length;r<n;r++){let n=t[r].toString(16);n.length<2&&(n="0"+n),e+="%"+n}return decodeURIComponent(e)}if(r.equals(E.UnicodeBigUnmarked))return String.fromCharCode.apply(null,new Uint16Array(t.buffer));throw new S(`Encoding ${this.encodingName(e)} not supported by fallback.`)}static isDecodeFallbackSupported(t){return t.equals(E.UTF8)||t.equals(E.ISO8859_1)||t.equals(E.ASCII)}static encodeFallback(t){const e=btoa(unescape(encodeURIComponent(t))).split(""),r=[];for(let t=0;t<e.length;t++)r.push(e[t].charCodeAt(0));return new Uint8Array(r)}}class _{static castAsNonUtf8Char(t,e=null){const r=e?e.getName():this.ISO88591;return C.decode(new Uint8Array([t]),r)}static guessEncoding(t,e){if(null!=e&&void 0!==e.get(A.CHARACTER_SET))return e.get(A.CHARACTER_SET).toString();const r=t.length;let n=!0,i=!0,s=!0,o=0,a=0,h=0,l=0,c=0,d=0,u=0,f=0,w=0,g=0,m=0;const I=t.length>3&&239===t[0]&&187===t[1]&&191===t[2];for(let e=0;e<r&&(n||i||s);e++){const r=255&t[e];s&&(o>0?128&r?o--:s=!1:128&r&&(64&r?(o++,32&r?(o++,16&r?(o++,8&r?s=!1:l++):h++):a++):s=!1)),n&&(r>127&&r<160?n=!1:r>159&&(r<192||215===r||247===r)&&m++),i&&(c>0?r<64||127===r||r>252?i=!1:c--:128===r||160===r||r>239?i=!1:r>160&&r<224?(d++,f=0,u++,u>w&&(w=u)):r>127?(c++,u=0,f++,f>g&&(g=f)):(u=0,f=0))}return s&&o>0&&(s=!1),i&&c>0&&(i=!1),s&&(I||a+h+l>0)?_.UTF8:i&&(_.ASSUME_SHIFT_JIS||w>=3||g>=3)?_.SHIFT_JIS:n&&i?2===w&&2===d||10*m>=r?_.SHIFT_JIS:_.ISO88591:n?_.ISO88591:i?_.SHIFT_JIS:s?_.UTF8:_.PLATFORM_DEFAULT_ENCODING}static format(t,...e){let r=-1;return t.replace(/%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g,(function(t,n,i,s,o,a){if("%%"===t)return"%";if(void 0===e[++r])return;t=s?parseInt(s.substr(1)):void 0;let h,l=o?parseInt(o.substr(1)):void 0;switch(a){case"s":h=e[r];break;case"c":h=e[r][0];break;case"f":h=parseFloat(e[r]).toFixed(t);break;case"p":h=parseFloat(e[r]).toPrecision(t);break;case"e":h=parseFloat(e[r]).toExponential(t);break;case"x":h=parseInt(e[r]).toString(l||16);break;case"d":h=parseFloat(parseInt(e[r],l||10).toPrecision(t)).toFixed(0)}h="object"==typeof h?JSON.stringify(h):(+h).toString(l);let c=parseInt(i),d=i&&i[0]+""=="0"?"0":" ";for(;h.length<c;)h=void 0!==n?h+d:d+h;return h}))}static getBytes(t,e){return C.encode(t,e)}static getCharCode(t,e=0){return t.charCodeAt(e)}static getCharAt(t){return String.fromCharCode(t)}}_.SHIFT_JIS=E.SJIS.getName(),_.GB2312="GB2312",_.ISO88591=E.ISO8859_1.getName(),_.EUC_JP="EUC_JP",_.UTF8=E.UTF8.getName(),_.PLATFORM_DEFAULT_ENCODING=_.UTF8,_.ASSUME_SHIFT_JIS=!1;class y{constructor(t=""){this.value=t}enableDecoding(t){return this.encoding=t,this}append(t){return"string"==typeof t?this.value+=t.toString():this.encoding?this.value+=_.castAsNonUtf8Char(t,this.encoding):this.value+=String.fromCharCode(t),this}appendChars(t,e,r){for(let n=e;e<e+r;n++)this.append(t[n]);return this}length(){return this.value.length}charAt(t){return this.value.charAt(t)}deleteCharAt(t){this.value=this.value.substr(0,t)+this.value.substring(t+1)}setCharAt(t,e){this.value=this.value.substr(0,t)+e+this.value.substr(t+1)}substring(t,e){return this.value.substring(t,e)}setLengthToZero(){this.value=""}toString(){return this.value}insert(t,e){this.value=this.value.substring(0,t)+e+this.value.substring(t)}}class M{constructor(t,e,r,n){if(this.width=t,this.height=e,this.rowSize=r,this.bits=n,null==e&&(e=t),this.height=e,t<1||e<1)throw new a("Both dimensions must be greater than 0");null==r&&(r=Math.floor((t+31)/32)),this.rowSize=r,null==n&&(this.bits=new Int32Array(this.rowSize*this.height))}static parseFromBooleanArray(t){const e=t.length,r=t[0].length,n=new M(r,e);for(let i=0;i<e;i++){const e=t[i];for(let t=0;t<r;t++)e[t]&&n.set(t,i)}return n}static parseFromString(t,e,r){if(null===t)throw new a("stringRepresentation cannot be null");const n=new Array(t.length);let i=0,s=0,o=-1,h=0,l=0;for(;l<t.length;)if("\n"===t.charAt(l)||"\r"===t.charAt(l)){if(i>s){if(-1===o)o=i-s;else if(i-s!==o)throw new a("row lengths do not match");s=i,h++}l++}else if(t.substring(l,l+e.length)===e)l+=e.length,n[i]=!0,i++;else{if(t.substring(l,l+r.length)!==r)throw new a("illegal character encountered: "+t.substring(l));l+=r.length,n[i]=!1,i++}if(i>s){if(-1===o)o=i-s;else if(i-s!==o)throw new a("row lengths do not match");h++}const c=new M(o,h);for(let t=0;t<i;t++)n[t]&&c.set(Math.floor(t%o),Math.floor(t/o));return c}get(t,e){const r=e*this.rowSize+Math.floor(t/32);return!!(this.bits[r]>>>(31&t)&1)}set(t,e){const r=e*this.rowSize+Math.floor(t/32);this.bits[r]|=1<<(31&t)&4294967295}unset(t,e){const r=e*this.rowSize+Math.floor(t/32);this.bits[r]&=~(1<<(31&t)&4294967295)}flip(t,e){const r=e*this.rowSize+Math.floor(t/32);this.bits[r]^=1<<(31&t)&4294967295}xor(t){if(this.width!==t.getWidth()||this.height!==t.getHeight()||this.rowSize!==t.getRowSize())throw new a("input matrix dimensions do not match");const e=new m(Math.floor(this.width/32)+1),r=this.rowSize,n=this.bits;for(let i=0,s=this.height;i<s;i++){const s=i*r,o=t.getRow(i,e).getBitArray();for(let t=0;t<r;t++)n[s+t]^=o[t]}}clear(){const t=this.bits,e=t.length;for(let r=0;r<e;r++)t[r]=0}setRegion(t,e,r,n){if(e<0||t<0)throw new a("Left and top must be nonnegative");if(n<1||r<1)throw new a("Height and width must be at least 1");const i=t+r,s=e+n;if(s>this.height||i>this.width)throw new a("The region must fit inside the matrix");const o=this.rowSize,h=this.bits;for(let r=e;r<s;r++){const e=r*o;for(let r=t;r<i;r++)h[e+Math.floor(r/32)]|=1<<(31&r)&4294967295}}getRow(t,e){null==e||e.getSize()<this.width?e=new m(this.width):e.clear();const r=this.rowSize,n=this.bits,i=t*r;for(let t=0;t<r;t++)e.setBulk(32*t,n[i+t]);return e}setRow(t,e){d.arraycopy(e.getBitArray(),0,this.bits,t*this.rowSize,this.rowSize)}rotate180(){const t=this.getWidth(),e=this.getHeight();let r=new m(t),n=new m(t);for(let t=0,i=Math.floor((e+1)/2);t<i;t++)r=this.getRow(t,r),n=this.getRow(e-1-t,n),r.reverse(),n.reverse(),this.setRow(t,n),this.setRow(e-1-t,r)}getEnclosingRectangle(){const t=this.width,e=this.height,r=this.rowSize,n=this.bits;let i=t,s=e,o=-1,a=-1;for(let t=0;t<e;t++)for(let e=0;e<r;e++){const h=n[t*r+e];if(0!==h){if(t<s&&(s=t),t>a&&(a=t),32*e<i){let t=0;for(;!(h<<31-t&4294967295);)t++;32*e+t<i&&(i=32*e+t)}if(32*e+31>o){let t=31;for(;h>>>t==0;)t--;32*e+t>o&&(o=32*e+t)}}}return o<i||a<s?null:Int32Array.from([i,s,o-i+1,a-s+1])}getTopLeftOnBit(){const t=this.rowSize,e=this.bits;let r=0;for(;r<e.length&&0===e[r];)r++;if(r===e.length)return null;const n=r/t;let i=r%t*32;const s=e[r];let o=0;for(;!(s<<31-o&4294967295);)o++;return i+=o,Int32Array.from([i,n])}getBottomRightOnBit(){const t=this.rowSize,e=this.bits;let r=e.length-1;for(;r>=0&&0===e[r];)r--;if(r<0)return null;const n=Math.floor(r/t);let i=32*Math.floor(r%t);const s=e[r];let o=31;for(;s>>>o==0;)o--;return i+=o,Int32Array.from([i,n])}getWidth(){return this.width}getHeight(){return this.height}getRowSize(){return this.rowSize}equals(t){if(!(t instanceof M))return!1;const e=t;return this.width===e.width&&this.height===e.height&&this.rowSize===e.rowSize&&w.equals(this.bits,e.bits)}hashCode(){let t=this.width;return t=31*t+this.width,t=31*t+this.height,t=31*t+this.rowSize,t=31*t+w.hashCode(this.bits),t}toString(t="X ",e="  ",r="\n"){return this.buildToString(t,e,r)}buildToString(t,e,r){let n=new y;for(let i=0,s=this.height;i<s;i++){for(let r=0,s=this.width;r<s;r++)n.append(this.get(r,i)?t:e);n.append(r)}return n.toString()}clone(){return new M(this.width,this.height,this.rowSize,this.bits.slice())}}class O extends s{static getNotFoundInstance(){return new O}}O.kind="NotFoundException";class N extends c{constructor(t){super(t),this.luminances=N.EMPTY,this.buckets=new Int32Array(N.LUMINANCE_BUCKETS)}getBlackRow(t,e){const r=this.getLuminanceSource(),n=r.getWidth();null==e||e.getSize()<n?e=new m(n):e.clear(),this.initArrays(n);const i=r.getRow(t,this.luminances),s=this.buckets;for(let t=0;t<n;t++)s[(255&i[t])>>N.LUMINANCE_SHIFT]++;const o=N.estimateBlackPoint(s);if(n<3)for(let t=0;t<n;t++)(255&i[t])<o&&e.set(t);else{let t=255&i[0],r=255&i[1];for(let s=1;s<n-1;s++){const n=255&i[s+1];(4*r-t-n)/2<o&&e.set(s),t=r,r=n}}return e}getBlackMatrix(){const t=this.getLuminanceSource(),e=t.getWidth(),r=t.getHeight(),n=new M(e,r);this.initArrays(e);const i=this.buckets;for(let n=1;n<5;n++){const s=Math.floor(r*n/5),o=t.getRow(s,this.luminances),a=Math.floor(4*e/5);for(let t=Math.floor(e/5);t<a;t++){i[(255&o[t])>>N.LUMINANCE_SHIFT]++}}const s=N.estimateBlackPoint(i),o=t.getMatrix();for(let t=0;t<r;t++){const r=t*e;for(let i=0;i<e;i++){(255&o[r+i])<s&&n.set(i,t)}}return n}createBinarizer(t){return new N(t)}initArrays(t){this.luminances.length<t&&(this.luminances=new Uint8ClampedArray(t));const e=this.buckets;for(let t=0;t<N.LUMINANCE_BUCKETS;t++)e[t]=0}static estimateBlackPoint(t){const e=t.length;let r=0,n=0,i=0;for(let s=0;s<e;s++)t[s]>i&&(n=s,i=t[s]),t[s]>r&&(r=t[s]);let s=0,o=0;for(let r=0;r<e;r++){const e=r-n,i=t[r]*e*e;i>o&&(s=r,o=i)}if(n>s){const t=n;n=s,s=t}if(s-n<=e/16)throw new O;let a=s-1,h=-1;for(let e=s-1;e>n;e--){const i=e-n,o=i*i*(s-e)*(r-t[e]);o>h&&(a=e,h=o)}return a<<N.LUMINANCE_SHIFT}}N.LUMINANCE_BITS=5,N.LUMINANCE_SHIFT=8-N.LUMINANCE_BITS,N.LUMINANCE_BUCKETS=1<<N.LUMINANCE_BITS,N.EMPTY=Uint8ClampedArray.from([0]);class b extends N{constructor(t){super(t),this.matrix=null}getBlackMatrix(){if(null!==this.matrix)return this.matrix;const t=this.getLuminanceSource(),e=t.getWidth(),r=t.getHeight();if(e>=b.MINIMUM_DIMENSION&&r>=b.MINIMUM_DIMENSION){const n=t.getMatrix();let i=e>>b.BLOCK_SIZE_POWER;e&b.BLOCK_SIZE_MASK&&i++;let s=r>>b.BLOCK_SIZE_POWER;r&b.BLOCK_SIZE_MASK&&s++;const o=b.calculateBlackPoints(n,i,s,e,r),a=new M(e,r);b.calculateThresholdForBlock(n,i,s,e,r,o,a),this.matrix=a}else this.matrix=super.getBlackMatrix();return this.matrix}createBinarizer(t){return new b(t)}static calculateThresholdForBlock(t,e,r,n,i,s,o){const a=i-b.BLOCK_SIZE,h=n-b.BLOCK_SIZE;for(let i=0;i<r;i++){let l=i<<b.BLOCK_SIZE_POWER;l>a&&(l=a);const c=b.cap(i,2,r-3);for(let r=0;r<e;r++){let i=r<<b.BLOCK_SIZE_POWER;i>h&&(i=h);const a=b.cap(r,2,e-3);let d=0;for(let t=-2;t<=2;t++){const e=s[c+t];d+=e[a-2]+e[a-1]+e[a]+e[a+1]+e[a+2]}const u=d/25;b.thresholdBlock(t,i,l,u,n,o)}}}static cap(t,e,r){return t<e?e:t>r?r:t}static thresholdBlock(t,e,r,n,i,s){for(let o=0,a=r*i+e;o<b.BLOCK_SIZE;o++,a+=i)for(let i=0;i<b.BLOCK_SIZE;i++)(255&t[a+i])<=n&&s.set(e+i,r+o)}static calculateBlackPoints(t,e,r,n,i){const s=i-b.BLOCK_SIZE,o=n-b.BLOCK_SIZE,a=new Array(r);for(let i=0;i<r;i++){a[i]=new Int32Array(e);let r=i<<b.BLOCK_SIZE_POWER;r>s&&(r=s);for(let s=0;s<e;s++){let e=s<<b.BLOCK_SIZE_POWER;e>o&&(e=o);let h=0,l=255,c=0;for(let i=0,s=r*n+e;i<b.BLOCK_SIZE;i++,s+=n){for(let e=0;e<b.BLOCK_SIZE;e++){const r=255&t[s+e];h+=r,r<l&&(l=r),r>c&&(c=r)}if(c-l>b.MIN_DYNAMIC_RANGE)for(i++,s+=n;i<b.BLOCK_SIZE;i++,s+=n)for(let e=0;e<b.BLOCK_SIZE;e++)h+=255&t[s+e]}let d=h>>2*b.BLOCK_SIZE_POWER;if(c-l<=b.MIN_DYNAMIC_RANGE&&(d=l/2,i>0&&s>0)){const t=(a[i-1][s]+2*a[i][s-1]+a[i-1][s-1])/4;l<t&&(d=t)}a[i][s]=d}}return a}}b.BLOCK_SIZE_POWER=3,b.BLOCK_SIZE=1<<b.BLOCK_SIZE_POWER,b.BLOCK_SIZE_MASK=b.BLOCK_SIZE-1,b.MINIMUM_DIMENSION=5*b.BLOCK_SIZE,b.MIN_DYNAMIC_RANGE=24;class T{constructor(t,e){this.width=t,this.height=e}getWidth(){return this.width}getHeight(){return this.height}isCropSupported(){return!1}crop(t,e,r,n){throw new S("This luminance source does not support cropping.")}isRotateSupported(){return!1}rotateCounterClockwise(){throw new S("This luminance source does not support rotation by 90 degrees.")}rotateCounterClockwise45(){throw new S("This luminance source does not support rotation by 45 degrees.")}toString(){const t=new Uint8ClampedArray(this.width);let e=new y;for(let r=0;r<this.height;r++){const n=this.getRow(r,t);for(let t=0;t<this.width;t++){const r=255&n[t];let i;i=r<64?"#":r<128?"+":r<192?".":" ",e.append(i)}e.append("\n")}return e.toString()}}class B extends T{constructor(t){super(t.getWidth(),t.getHeight()),this.delegate=t}getRow(t,e){const r=this.delegate.getRow(t,e),n=this.getWidth();for(let t=0;t<n;t++)r[t]=255-(255&r[t]);return r}getMatrix(){const t=this.delegate.getMatrix(),e=this.getWidth()*this.getHeight(),r=new Uint8ClampedArray(e);for(let n=0;n<e;n++)r[n]=255-(255&t[n]);return r}isCropSupported(){return this.delegate.isCropSupported()}crop(t,e,r,n){return new B(this.delegate.crop(t,e,r,n))}isRotateSupported(){return this.delegate.isRotateSupported()}invert(){return this.delegate}rotateCounterClockwise(){return new B(this.delegate.rotateCounterClockwise())}rotateCounterClockwise45(){return new B(this.delegate.rotateCounterClockwise45())}}class R extends T{constructor(t,e=!1){super(t.width,t.height),this.canvas=t,this.tempCanvasElement=null,this.buffer=R.makeBufferFromCanvasImageData(t,e)}static makeBufferFromCanvasImageData(t,e=!1){const r=t.getContext("2d").getImageData(0,0,t.width,t.height);return R.toGrayscaleBuffer(r.data,t.width,t.height,e)}static toGrayscaleBuffer(t,e,r,n=!1){const i=new Uint8ClampedArray(e*r);if(R.FRAME_INDEX=!R.FRAME_INDEX,R.FRAME_INDEX||!n)for(let e=0,r=0,n=t.length;e<n;e+=4,r++){let n;if(0===t[e+3])n=255;else{n=306*t[e]+601*t[e+1]+117*t[e+2]+512>>10}i[r]=n}else for(let e=0,r=0,n=t.length;e<n;e+=4,r++){let n;if(0===t[e+3])n=255;else{n=306*t[e]+601*t[e+1]+117*t[e+2]+512>>10}i[r]=255-n}return i}getRow(t,e){if(t<0||t>=this.getHeight())throw new a("Requested row is outside the image: "+t);const r=this.getWidth(),n=t*r;return null===e?e=this.buffer.slice(n,n+r):(e.length<r&&(e=new Uint8ClampedArray(r)),e.set(this.buffer.slice(n,n+r))),e}getMatrix(){return this.buffer}isCropSupported(){return!0}crop(t,e,r,n){return super.crop(t,e,r,n),this}isRotateSupported(){return!0}rotateCounterClockwise(){return this.rotate(-90),this}rotateCounterClockwise45(){return this.rotate(-45),this}getTempCanvasElement(){if(null===this.tempCanvasElement){const t=this.canvas.ownerDocument.createElement("canvas");t.width=this.canvas.width,t.height=this.canvas.height,this.tempCanvasElement=t}return this.tempCanvasElement}rotate(t){const e=this.getTempCanvasElement(),r=e.getContext("2d"),n=t*R.DEGREE_TO_RADIANS,i=this.canvas.width,s=this.canvas.height,o=Math.ceil(Math.abs(Math.cos(n))*i+Math.abs(Math.sin(n))*s),a=Math.ceil(Math.abs(Math.sin(n))*i+Math.abs(Math.cos(n))*s);return e.width=o,e.height=a,r.translate(o/2,a/2),r.rotate(n),r.drawImage(this.canvas,i/-2,s/-2),this.buffer=R.makeBufferFromCanvasImageData(e),this}invert(){return new B(this)}}R.DEGREE_TO_RADIANS=Math.PI/180,R.FRAME_INDEX=!0;class v{constructor(t,e,r){this.deviceId=t,this.label=e,this.kind="videoinput",this.groupId=r||void 0}toJSON(){return{kind:this.kind,groupId:this.groupId,deviceId:this.deviceId,label:this.label}}}var D,P=(globalThis||global||self||window?(globalThis||global||self||window||void 0).__awaiter:void 0)||function(t,e,r,n){return new(r||(r=Promise))((function(i,s){function o(t){try{h(n.next(t))}catch(t){s(t)}}function a(t){try{h(n.throw(t))}catch(t){s(t)}}function h(t){var e;t.done?i(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(o,a)}h((n=n.apply(t,e||[])).next())}))};class F{get hasNavigator(){return"undefined"!=typeof navigator}get isMediaDevicesSuported(){return this.hasNavigator&&!!navigator.mediaDevices}get canEnumerateDevices(){return!(!this.isMediaDevicesSuported||!navigator.mediaDevices.enumerateDevices)}get timeBetweenDecodingAttempts(){return this._timeBetweenDecodingAttempts}set timeBetweenDecodingAttempts(t){this._timeBetweenDecodingAttempts=t<0?0:t}set hints(t){this._hints=t||null}get hints(){return this._hints}constructor(t,e=500,r){this.reader=t,this.timeBetweenScansMillis=e,this._hints=r,this._stopContinuousDecode=!1,this._stopAsyncDecode=!1,this._timeBetweenDecodingAttempts=0}listVideoInputDevices(){return P(this,void 0,void 0,(function*(){if(!this.hasNavigator)throw new Error("Can't enumerate devices, navigator is not present.");if(!this.canEnumerateDevices)throw new Error("Can't enumerate devices, method not supported.");const t=yield navigator.mediaDevices.enumerateDevices(),e=[];for(const r of t){const t="video"===r.kind?"videoinput":r.kind;if("videoinput"!==t)continue;const n={deviceId:r.deviceId||r.id,label:r.label||`Video device ${e.length+1}`,kind:t,groupId:r.groupId};e.push(n)}return e}))}getVideoInputDevices(){return P(this,void 0,void 0,(function*(){return(yield this.listVideoInputDevices()).map((t=>new v(t.deviceId,t.label)))}))}findDeviceById(t){return P(this,void 0,void 0,(function*(){const e=yield this.listVideoInputDevices();return e?e.find((e=>e.deviceId===t)):null}))}decodeFromInputVideoDevice(t,e){return P(this,void 0,void 0,(function*(){return yield this.decodeOnceFromVideoDevice(t,e)}))}decodeOnceFromVideoDevice(t,e){return P(this,void 0,void 0,(function*(){let r;this.reset(),r=t?{deviceId:{exact:t}}:{facingMode:"environment"};const n={video:r};return yield this.decodeOnceFromConstraints(n,e)}))}decodeOnceFromConstraints(t,e){return P(this,void 0,void 0,(function*(){const r=yield navigator.mediaDevices.getUserMedia(t);return yield this.decodeOnceFromStream(r,e)}))}decodeOnceFromStream(t,e){return P(this,void 0,void 0,(function*(){this.reset();const r=yield this.attachStreamToVideo(t,e);return yield this.decodeOnce(r)}))}decodeFromInputVideoDeviceContinuously(t,e,r){return P(this,void 0,void 0,(function*(){return yield this.decodeFromVideoDevice(t,e,r)}))}decodeFromVideoDevice(t,e,r){return P(this,void 0,void 0,(function*(){let n;n=t?{deviceId:{exact:t}}:{facingMode:"environment"};const i={video:n};return yield this.decodeFromConstraints(i,e,r)}))}decodeFromConstraints(t,e,r){return P(this,void 0,void 0,(function*(){const n=yield navigator.mediaDevices.getUserMedia(t);return yield this.decodeFromStream(n,e,r)}))}decodeFromStream(t,e,r){return P(this,void 0,void 0,(function*(){this.reset();const n=yield this.attachStreamToVideo(t,e);return yield this.decodeContinuously(n,r)}))}stopAsyncDecode(){this._stopAsyncDecode=!0}stopContinuousDecode(){this._stopContinuousDecode=!0}attachStreamToVideo(t,e){return P(this,void 0,void 0,(function*(){const r=this.prepareVideoElement(e);return this.addVideoSource(r,t),this.videoElement=r,this.stream=t,yield this.playVideoOnLoadAsync(r),r}))}playVideoOnLoadAsync(t){return new Promise(((e,r)=>this.playVideoOnLoad(t,(()=>e()))))}playVideoOnLoad(t,e){this.videoEndedListener=()=>this.stopStreams(),this.videoCanPlayListener=()=>this.tryPlayVideo(t),t.addEventListener("ended",this.videoEndedListener),t.addEventListener("canplay",this.videoCanPlayListener),t.addEventListener("playing",e),this.tryPlayVideo(t)}isVideoPlaying(t){return t.currentTime>0&&!t.paused&&!t.ended&&t.readyState>2}tryPlayVideo(t){return P(this,void 0,void 0,(function*(){if(this.isVideoPlaying(t))console.warn("Trying to play video that is already playing.");else try{yield t.play()}catch(t){console.warn("It was not possible to play the video.")}}))}getMediaElement(t,e){const r=document.getElementById(t);if(!r)throw new o(`element with id '${t}' not found`);if(r.nodeName.toLowerCase()!==e.toLowerCase())throw new o(`element with id '${t}' must be an ${e} element`);return r}decodeFromImage(t,e){if(!t&&!e)throw new o("either imageElement with a src set or an url must be provided");return e&&!t?this.decodeFromImageUrl(e):this.decodeFromImageElement(t)}decodeFromVideo(t,e){if(!t&&!e)throw new o("Either an element with a src set or an URL must be provided");return e&&!t?this.decodeFromVideoUrl(e):this.decodeFromVideoElement(t)}decodeFromVideoContinuously(t,e,r){if(void 0===t&&void 0===e)throw new o("Either an element with a src set or an URL must be provided");return e&&!t?this.decodeFromVideoUrlContinuously(e,r):this.decodeFromVideoElementContinuously(t,r)}decodeFromImageElement(t){if(!t)throw new o("An image element must be provided.");this.reset();const e=this.prepareImageElement(t);let r;return this.imageElement=e,r=this.isImageLoaded(e)?this.decodeOnce(e,!1,!0):this._decodeOnLoadImage(e),r}decodeFromVideoElement(t){const e=this._decodeFromVideoElementSetup(t);return this._decodeOnLoadVideo(e)}decodeFromVideoElementContinuously(t,e){const r=this._decodeFromVideoElementSetup(t);return this._decodeOnLoadVideoContinuously(r,e)}_decodeFromVideoElementSetup(t){if(!t)throw new o("A video element must be provided.");this.reset();const e=this.prepareVideoElement(t);return this.videoElement=e,e}decodeFromImageUrl(t){if(!t)throw new o("An URL must be provided.");this.reset();const e=this.prepareImageElement();this.imageElement=e;const r=this._decodeOnLoadImage(e);return e.src=t,r}decodeFromVideoUrl(t){if(!t)throw new o("An URL must be provided.");this.reset();const e=this.prepareVideoElement(),r=this.decodeFromVideoElement(e);return e.src=t,r}decodeFromVideoUrlContinuously(t,e){if(!t)throw new o("An URL must be provided.");this.reset();const r=this.prepareVideoElement(),n=this.decodeFromVideoElementContinuously(r,e);return r.src=t,n}_decodeOnLoadImage(t){return new Promise(((e,r)=>{this.imageLoadedListener=()=>this.decodeOnce(t,!1,!0).then(e,r),t.addEventListener("load",this.imageLoadedListener)}))}_decodeOnLoadVideo(t){return P(this,void 0,void 0,(function*(){return yield this.playVideoOnLoadAsync(t),yield this.decodeOnce(t)}))}_decodeOnLoadVideoContinuously(t,e){return P(this,void 0,void 0,(function*(){yield this.playVideoOnLoadAsync(t),this.decodeContinuously(t,e)}))}isImageLoaded(t){return!!t.complete&&0!==t.naturalWidth}prepareImageElement(t){let e;return void 0===t&&(e=document.createElement("img"),e.width=200,e.height=200),"string"==typeof t&&(e=this.getMediaElement(t,"img")),t instanceof HTMLImageElement&&(e=t),e}prepareVideoElement(t){let e;return t||"undefined"==typeof document||(e=document.createElement("video"),e.width=200,e.height=200),"string"==typeof t&&(e=this.getMediaElement(t,"video")),t instanceof HTMLVideoElement&&(e=t),e.setAttribute("autoplay","true"),e.setAttribute("muted","true"),e.setAttribute("playsinline","true"),e}decodeOnce(t,e=!0,r=!0){this._stopAsyncDecode=!1;const n=(i,s)=>{if(this._stopAsyncDecode)return s(new O("Video stream has ended before any code could be detected.")),void(this._stopAsyncDecode=void 0);try{i(this.decode(t))}catch(t){if(e&&t instanceof O||(t instanceof l||t instanceof p)&&r)return setTimeout(n,this._timeBetweenDecodingAttempts,i,s);s(t)}};return new Promise(((t,e)=>n(t,e)))}decodeContinuously(t,e){this._stopContinuousDecode=!1;const r=()=>{if(this._stopContinuousDecode)this._stopContinuousDecode=void 0;else try{const n=this.decode(t);e(n,null),setTimeout(r,this.timeBetweenScansMillis)}catch(t){e(null,t);(t instanceof l||t instanceof p||t instanceof O)&&setTimeout(r,this._timeBetweenDecodingAttempts)}};r()}decode(t){const e=this.createBinaryBitmap(t);return this.decodeBitmap(e)}createBinaryBitmap(t){this.getCaptureCanvasContext(t);let e=!1;t instanceof HTMLVideoElement?(this.drawFrameOnCanvas(t),e=!0):this.drawImageOnCanvas(t);const r=this.getCaptureCanvas(t),n=new R(r,e),i=new b(n);return new h(i)}getCaptureCanvasContext(t){if(!this.captureCanvasContext){const e=this.getCaptureCanvas(t);let r;try{r=e.getContext("2d",{willReadFrequently:!0})}catch(t){r=e.getContext("2d")}this.captureCanvasContext=r}return this.captureCanvasContext}getCaptureCanvas(t){if(!this.captureCanvas){const e=this.createCaptureCanvas(t);this.captureCanvas=e}return this.captureCanvas}drawFrameOnCanvas(t,e={sx:0,sy:0,sWidth:t.videoWidth,sHeight:t.videoHeight,dx:0,dy:0,dWidth:t.videoWidth,dHeight:t.videoHeight},r=this.captureCanvasContext){r.drawImage(t,e.sx,e.sy,e.sWidth,e.sHeight,e.dx,e.dy,e.dWidth,e.dHeight)}drawImageOnCanvas(t,e={sx:0,sy:0,sWidth:t.naturalWidth,sHeight:t.naturalHeight,dx:0,dy:0,dWidth:t.naturalWidth,dHeight:t.naturalHeight},r=this.captureCanvasContext){r.drawImage(t,e.sx,e.sy,e.sWidth,e.sHeight,e.dx,e.dy,e.dWidth,e.dHeight)}decodeBitmap(t){try{return this.reader.decode(t,this._hints)}finally{this.reader.reset()}}createCaptureCanvas(t){if("undefined"==typeof document)return this._destroyCaptureCanvas(),null;const e=document.createElement("canvas");let r,n;return void 0!==t&&(t instanceof HTMLVideoElement?(r=t.videoWidth,n=t.videoHeight):t instanceof HTMLImageElement&&(r=t.naturalWidth||t.width,n=t.naturalHeight||t.height)),e.style.width=r+"px",e.style.height=n+"px",e.width=r,e.height=n,e}stopStreams(){this.stream&&(this.stream.getVideoTracks().forEach((t=>t.stop())),this.stream=void 0),!1===this._stopAsyncDecode&&this.stopAsyncDecode(),!1===this._stopContinuousDecode&&this.stopContinuousDecode()}reset(){this.stopStreams(),this._destroyVideoElement(),this._destroyImageElement(),this._destroyCaptureCanvas()}_destroyVideoElement(){this.videoElement&&(void 0!==this.videoEndedListener&&this.videoElement.removeEventListener("ended",this.videoEndedListener),void 0!==this.videoPlayingEventListener&&this.videoElement.removeEventListener("playing",this.videoPlayingEventListener),void 0!==this.videoCanPlayListener&&this.videoElement.removeEventListener("loadedmetadata",this.videoCanPlayListener),this.cleanVideoSource(this.videoElement),this.videoElement=void 0)}_destroyImageElement(){this.imageElement&&(void 0!==this.imageLoadedListener&&this.imageElement.removeEventListener("load",this.imageLoadedListener),this.imageElement.src=void 0,this.imageElement.removeAttribute("src"),this.imageElement=void 0)}_destroyCaptureCanvas(){this.captureCanvasContext=void 0,this.captureCanvas=void 0}addVideoSource(t,e){try{t.srcObject=e}catch(r){t.src=URL.createObjectURL(e)}}cleanVideoSource(t){try{t.srcObject=null}catch(e){t.src=""}this.videoElement.removeAttribute("src")}}!function(t){t[t.AZTEC=0]="AZTEC",t[t.CODABAR=1]="CODABAR",t[t.CODE_39=2]="CODE_39",t[t.CODE_93=3]="CODE_93",t[t.CODE_128=4]="CODE_128",t[t.DATA_MATRIX=5]="DATA_MATRIX",t[t.EAN_8=6]="EAN_8",t[t.EAN_13=7]="EAN_13",t[t.ITF=8]="ITF",t[t.MAXICODE=9]="MAXICODE",t[t.PDF_417=10]="PDF_417",t[t.QR_CODE=11]="QR_CODE",t[t.RSS_14=12]="RSS_14",t[t.RSS_EXPANDED=13]="RSS_EXPANDED",t[t.UPC_A=14]="UPC_A",t[t.UPC_E=15]="UPC_E",t[t.UPC_EAN_EXTENSION=16]="UPC_EAN_EXTENSION"}(D||(D={}));var k,L=D;class U{constructor(t,e,r=(null==e?0:8*e.length),n,i,s=d.currentTimeMillis()){this.text=t,this.rawBytes=e,this.numBits=r,this.resultPoints=n,this.format=i,this.timestamp=s,this.text=t,this.rawBytes=e,this.numBits=null==r?null==e?0:8*e.length:r,this.resultPoints=n,this.format=i,this.resultMetadata=null,this.timestamp=null==s?d.currentTimeMillis():s}getText(){return this.text}getRawBytes(){return this.rawBytes}getNumBits(){return this.numBits}getResultPoints(){return this.resultPoints}getBarcodeFormat(){return this.format}getResultMetadata(){return this.resultMetadata}putMetadata(t,e){null===this.resultMetadata&&(this.resultMetadata=new Map),this.resultMetadata.set(t,e)}putAllMetadata(t){null!==t&&(null===this.resultMetadata?this.resultMetadata=t:this.resultMetadata=new Map(t))}addResultPoints(t){const e=this.resultPoints;if(null===e)this.resultPoints=t;else if(null!==t&&t.length>0){const r=new Array(e.length+t.length);d.arraycopy(e,0,r,0,e.length),d.arraycopy(t,0,r,e.length,t.length),this.resultPoints=r}}getTimestamp(){return this.timestamp}toString(){return this.text}}!function(t){t[t.OTHER=0]="OTHER",t[t.ORIENTATION=1]="ORIENTATION",t[t.BYTE_SEGMENTS=2]="BYTE_SEGMENTS",t[t.ERROR_CORRECTION_LEVEL=3]="ERROR_CORRECTION_LEVEL",t[t.ISSUE_NUMBER=4]="ISSUE_NUMBER",t[t.SUGGESTED_PRICE=5]="SUGGESTED_PRICE",t[t.POSSIBLE_COUNTRY=6]="POSSIBLE_COUNTRY",t[t.UPC_EAN_EXTENSION=7]="UPC_EAN_EXTENSION",t[t.PDF417_EXTRA_METADATA=8]="PDF417_EXTRA_METADATA",t[t.STRUCTURED_APPEND_SEQUENCE=9]="STRUCTURED_APPEND_SEQUENCE",t[t.STRUCTURED_APPEND_PARITY=10]="STRUCTURED_APPEND_PARITY"}(k||(k={}));var x,V,z,H,K=k;class W{exp(t){return this.expTable[t]}log(t){if(0===t)throw new a;return this.logTable[t]}static addOrSubtract(t,e){return t^e}}class G{constructor(t,e){if(0===e.length)throw new a;this.field=t;const r=e.length;if(r>1&&0===e[0]){let t=1;for(;t<r&&0===e[t];)t++;t===r?this.coefficients=Int32Array.from([0]):(this.coefficients=new Int32Array(r-t),d.arraycopy(e,t,this.coefficients,0,this.coefficients.length))}else this.coefficients=e}getCoefficients(){return this.coefficients}getDegree(){return this.coefficients.length-1}isZero(){return 0===this.coefficients[0]}getCoefficient(t){return this.coefficients[this.coefficients.length-1-t]}evaluateAt(t){if(0===t)return this.getCoefficient(0);const e=this.coefficients;let r;if(1===t){r=0;for(let t=0,n=e.length;t!==n;t++){const n=e[t];r=W.addOrSubtract(r,n)}return r}r=e[0];const n=e.length,i=this.field;for(let s=1;s<n;s++)r=W.addOrSubtract(i.multiply(t,r),e[s]);return r}addOrSubtract(t){if(!this.field.equals(t.field))throw new a("GenericGFPolys do not have same GenericGF field");if(this.isZero())return t;if(t.isZero())return this;let e=this.coefficients,r=t.coefficients;if(e.length>r.length){const t=e;e=r,r=t}let n=new Int32Array(r.length);const i=r.length-e.length;d.arraycopy(r,0,n,0,i);for(let t=i;t<r.length;t++)n[t]=W.addOrSubtract(e[t-i],r[t]);return new G(this.field,n)}multiply(t){if(!this.field.equals(t.field))throw new a("GenericGFPolys do not have same GenericGF field");if(this.isZero()||t.isZero())return this.field.getZero();const e=this.coefficients,r=e.length,n=t.coefficients,i=n.length,s=new Int32Array(r+i-1),o=this.field;for(let t=0;t<r;t++){const r=e[t];for(let e=0;e<i;e++)s[t+e]=W.addOrSubtract(s[t+e],o.multiply(r,n[e]))}return new G(o,s)}multiplyScalar(t){if(0===t)return this.field.getZero();if(1===t)return this;const e=this.coefficients.length,r=this.field,n=new Int32Array(e),i=this.coefficients;for(let s=0;s<e;s++)n[s]=r.multiply(i[s],t);return new G(r,n)}multiplyByMonomial(t,e){if(t<0)throw new a;if(0===e)return this.field.getZero();const r=this.coefficients,n=r.length,i=new Int32Array(n+t),s=this.field;for(let t=0;t<n;t++)i[t]=s.multiply(r[t],e);return new G(s,i)}divide(t){if(!this.field.equals(t.field))throw new a("GenericGFPolys do not have same GenericGF field");if(t.isZero())throw new a("Divide by 0");const e=this.field;let r=e.getZero(),n=this;const i=t.getCoefficient(t.getDegree()),s=e.inverse(i);for(;n.getDegree()>=t.getDegree()&&!n.isZero();){const i=n.getDegree()-t.getDegree(),o=e.multiply(n.getCoefficient(n.getDegree()),s),a=t.multiplyByMonomial(i,o),h=e.buildMonomial(i,o);r=r.addOrSubtract(h),n=n.addOrSubtract(a)}return[r,n]}toString(){let t="";for(let e=this.getDegree();e>=0;e--){let r=this.getCoefficient(e);if(0!==r){if(r<0?(t+=" - ",r=-r):t.length>0&&(t+=" + "),0===e||1!==r){const e=this.field.log(r);0===e?t+="1":1===e?t+="a":(t+="a^",t+=e)}0!==e&&(1===e?t+="x":(t+="x^",t+=e))}}return t}}class Z extends s{}Z.kind="ArithmeticException";class X extends W{constructor(t,e,r){super(),this.primitive=t,this.size=e,this.generatorBase=r;const n=new Int32Array(e);let i=1;for(let r=0;r<e;r++)n[r]=i,i*=2,i>=e&&(i^=t,i&=e-1);this.expTable=n;const s=new Int32Array(e);for(let t=0;t<e-1;t++)s[n[t]]=t;this.logTable=s,this.zero=new G(this,Int32Array.from([0])),this.one=new G(this,Int32Array.from([1]))}getZero(){return this.zero}getOne(){return this.one}buildMonomial(t,e){if(t<0)throw new a;if(0===e)return this.zero;const r=new Int32Array(t+1);return r[0]=e,new G(this,r)}inverse(t){if(0===t)throw new Z;return this.expTable[this.size-this.logTable[t]-1]}multiply(t,e){return 0===t||0===e?0:this.expTable[(this.logTable[t]+this.logTable[e])%(this.size-1)]}getSize(){return this.size}getGeneratorBase(){return this.generatorBase}toString(){return"GF(0x"+g.toHexString(this.primitive)+","+this.size+")"}equals(t){return t===this}}X.AZTEC_DATA_12=new X(4201,4096,1),X.AZTEC_DATA_10=new X(1033,1024,1),X.AZTEC_DATA_6=new X(67,64,1),X.AZTEC_PARAM=new X(19,16,1),X.QR_CODE_FIELD_256=new X(285,256,0),X.DATA_MATRIX_FIELD_256=new X(301,256,1),X.AZTEC_DATA_8=X.DATA_MATRIX_FIELD_256,X.MAXICODE_FIELD_64=X.AZTEC_DATA_6;class Y extends s{}Y.kind="ReedSolomonException";class Q extends s{}Q.kind="IllegalStateException";class q{constructor(t){this.field=t}decode(t,e){const r=this.field,n=new G(r,t),i=new Int32Array(e);let s=!0;for(let t=0;t<e;t++){const e=n.evaluateAt(r.exp(t+r.getGeneratorBase()));i[i.length-1-t]=e,0!==e&&(s=!1)}if(s)return;const o=new G(r,i),a=this.runEuclideanAlgorithm(r.buildMonomial(e,1),o,e),h=a[0],l=a[1],c=this.findErrorLocations(h),d=this.findErrorMagnitudes(l,c);for(let e=0;e<c.length;e++){const n=t.length-1-r.log(c[e]);if(n<0)throw new Y("Bad error location");t[n]=X.addOrSubtract(t[n],d[e])}}runEuclideanAlgorithm(t,e,r){if(t.getDegree()<e.getDegree()){const r=t;t=e,e=r}const n=this.field;let i=t,s=e,o=n.getZero(),a=n.getOne();for(;s.getDegree()>=(r/2|0);){let t=i,e=o;if(i=s,o=a,i.isZero())throw new Y("r_{i-1} was zero");s=t;let r=n.getZero();const h=i.getCoefficient(i.getDegree()),l=n.inverse(h);for(;s.getDegree()>=i.getDegree()&&!s.isZero();){const t=s.getDegree()-i.getDegree(),e=n.multiply(s.getCoefficient(s.getDegree()),l);r=r.addOrSubtract(n.buildMonomial(t,e)),s=s.addOrSubtract(i.multiplyByMonomial(t,e))}if(a=r.multiply(o).addOrSubtract(e),s.getDegree()>=i.getDegree())throw new Q("Division algorithm failed to reduce polynomial?")}const h=a.getCoefficient(0);if(0===h)throw new Y("sigmaTilde(0) was zero");const l=n.inverse(h);return[a.multiplyScalar(l),s.multiplyScalar(l)]}findErrorLocations(t){const e=t.getDegree();if(1===e)return Int32Array.from([t.getCoefficient(1)]);const r=new Int32Array(e);let n=0;const i=this.field;for(let s=1;s<i.getSize()&&n<e;s++)0===t.evaluateAt(s)&&(r[n]=i.inverse(s),n++);if(n!==e)throw new Y("Error locator degree does not match number of roots");return r}findErrorMagnitudes(t,e){const r=e.length,n=new Int32Array(r),i=this.field;for(let s=0;s<r;s++){const o=i.inverse(e[s]);let a=1;for(let t=0;t<r;t++)if(s!==t){const r=i.multiply(e[t],o),n=1&r?-2&r:1|r;a=i.multiply(a,n)}n[s]=i.multiply(t.evaluateAt(o),i.inverse(a)),0!==i.getGeneratorBase()&&(n[s]=i.multiply(n[s],o))}return n}}!function(t){t[t.L=0]="L",t[t.M=1]="M",t[t.Q=2]="Q",t[t.H=3]="H"}(x||(x={}));class J{constructor(t,e,r){this.value=t,this.stringValue=e,this.bits=r,J.FOR_BITS.set(r,this),J.FOR_VALUE.set(t,this)}getValue(){return this.value}getBits(){return this.bits}static fromString(t){switch(t){case"L":return J.L;case"M":return J.M;case"Q":return J.Q;case"H":return J.H;default:throw new o(t+"not available")}}toString(){return this.stringValue}equals(t){if(!(t instanceof J))return!1;const e=t;return this.value===e.value}static forBits(t){if(t<0||t>=J.FOR_BITS.size)throw new a;return J.FOR_BITS.get(t)}}J.FOR_BITS=new Map,J.FOR_VALUE=new Map,J.L=new J(x.L,"L",1),J.M=new J(x.M,"M",0),J.Q=new J(x.Q,"Q",3),J.H=new J(x.H,"H",2);class j{constructor(t){this.errorCorrectionLevel=J.forBits(t>>3&3),this.dataMask=7&t}static numBitsDiffering(t,e){return g.bitCount(t^e)}static decodeFormatInformation(t,e){const r=j.doDecodeFormatInformation(t,e);return null!==r?r:j.doDecodeFormatInformation(t^j.FORMAT_INFO_MASK_QR,e^j.FORMAT_INFO_MASK_QR)}static doDecodeFormatInformation(t,e){let r=Number.MAX_SAFE_INTEGER,n=0;for(const i of j.FORMAT_INFO_DECODE_LOOKUP){const s=i[0];if(s===t||s===e)return new j(i[1]);let o=j.numBitsDiffering(t,s);o<r&&(n=i[1],r=o),t!==e&&(o=j.numBitsDiffering(e,s),o<r&&(n=i[1],r=o))}return r<=3?new j(n):null}getErrorCorrectionLevel(){return this.errorCorrectionLevel}getDataMask(){return this.dataMask}hashCode(){return this.errorCorrectionLevel.getBits()<<3|this.dataMask}equals(t){if(!(t instanceof j))return!1;const e=t;return this.errorCorrectionLevel===e.errorCorrectionLevel&&this.dataMask===e.dataMask}}j.FORMAT_INFO_MASK_QR=21522,j.FORMAT_INFO_DECODE_LOOKUP=[Int32Array.from([21522,0]),Int32Array.from([20773,1]),Int32Array.from([24188,2]),Int32Array.from([23371,3]),Int32Array.from([17913,4]),Int32Array.from([16590,5]),Int32Array.from([20375,6]),Int32Array.from([19104,7]),Int32Array.from([30660,8]),Int32Array.from([29427,9]),Int32Array.from([32170,10]),Int32Array.from([30877,11]),Int32Array.from([26159,12]),Int32Array.from([25368,13]),Int32Array.from([27713,14]),Int32Array.from([26998,15]),Int32Array.from([5769,16]),Int32Array.from([5054,17]),Int32Array.from([7399,18]),Int32Array.from([6608,19]),Int32Array.from([1890,20]),Int32Array.from([597,21]),Int32Array.from([3340,22]),Int32Array.from([2107,23]),Int32Array.from([13663,24]),Int32Array.from([12392,25]),Int32Array.from([16177,26]),Int32Array.from([14854,27]),Int32Array.from([9396,28]),Int32Array.from([8579,29]),Int32Array.from([11994,30]),Int32Array.from([11245,31])];class ${constructor(t,...e){this.ecCodewordsPerBlock=t,this.ecBlocks=e}getECCodewordsPerBlock(){return this.ecCodewordsPerBlock}getNumBlocks(){let t=0;const e=this.ecBlocks;for(const r of e)t+=r.getCount();return t}getTotalECCodewords(){return this.ecCodewordsPerBlock*this.getNumBlocks()}getECBlocks(){return this.ecBlocks}}class tt{constructor(t,e){this.count=t,this.dataCodewords=e}getCount(){return this.count}getDataCodewords(){return this.dataCodewords}}class et{constructor(t,e,...r){this.versionNumber=t,this.alignmentPatternCenters=e,this.ecBlocks=r;let n=0;const i=r[0].getECCodewordsPerBlock(),s=r[0].getECBlocks();for(const t of s)n+=t.getCount()*(t.getDataCodewords()+i);this.totalCodewords=n}getVersionNumber(){return this.versionNumber}getAlignmentPatternCenters(){return this.alignmentPatternCenters}getTotalCodewords(){return this.totalCodewords}getDimensionForVersion(){return 17+4*this.versionNumber}getECBlocksForLevel(t){return this.ecBlocks[t.getValue()]}static getProvisionalVersionForDimension(t){if(t%4!=1)throw new p;try{return this.getVersionForNumber((t-17)/4)}catch(t){throw new p}}static getVersionForNumber(t){if(t<1||t>40)throw new a;return et.VERSIONS[t-1]}static decodeVersionInformation(t){let e=Number.MAX_SAFE_INTEGER,r=0;for(let n=0;n<et.VERSION_DECODE_INFO.length;n++){const i=et.VERSION_DECODE_INFO[n];if(i===t)return et.getVersionForNumber(n+7);const s=j.numBitsDiffering(t,i);s<e&&(r=n+7,e=s)}return e<=3?et.getVersionForNumber(r):null}buildFunctionPattern(){const t=this.getDimensionForVersion(),e=new M(t);e.setRegion(0,0,9,9),e.setRegion(t-8,0,8,9),e.setRegion(0,t-8,9,8);const r=this.alignmentPatternCenters.length;for(let t=0;t<r;t++){const n=this.alignmentPatternCenters[t]-2;for(let i=0;i<r;i++)0===t&&(0===i||i===r-1)||t===r-1&&0===i||e.setRegion(this.alignmentPatternCenters[i]-2,n,5,5)}return e.setRegion(6,9,1,t-17),e.setRegion(9,6,t-17,1),this.versionNumber>6&&(e.setRegion(t-11,0,3,6),e.setRegion(0,t-11,6,3)),e}toString(){return""+this.versionNumber}}et.VERSION_DECODE_INFO=Int32Array.from([31892,34236,39577,42195,48118,51042,55367,58893,63784,68472,70749,76311,79154,84390,87683,92361,96236,102084,102881,110507,110734,117786,119615,126325,127568,133589,136944,141498,145311,150283,152622,158308,161089,167017]),et.VERSIONS=[new et(1,new Int32Array(0),new $(7,new tt(1,19)),new $(10,new tt(1,16)),new $(13,new tt(1,13)),new $(17,new tt(1,9))),new et(2,Int32Array.from([6,18]),new $(10,new tt(1,34)),new $(16,new tt(1,28)),new $(22,new tt(1,22)),new $(28,new tt(1,16))),new et(3,Int32Array.from([6,22]),new $(15,new tt(1,55)),new $(26,new tt(1,44)),new $(18,new tt(2,17)),new $(22,new tt(2,13))),new et(4,Int32Array.from([6,26]),new $(20,new tt(1,80)),new $(18,new tt(2,32)),new $(26,new tt(2,24)),new $(16,new tt(4,9))),new et(5,Int32Array.from([6,30]),new $(26,new tt(1,108)),new $(24,new tt(2,43)),new $(18,new tt(2,15),new tt(2,16)),new $(22,new tt(2,11),new tt(2,12))),new et(6,Int32Array.from([6,34]),new $(18,new tt(2,68)),new $(16,new tt(4,27)),new $(24,new tt(4,19)),new $(28,new tt(4,15))),new et(7,Int32Array.from([6,22,38]),new $(20,new tt(2,78)),new $(18,new tt(4,31)),new $(18,new tt(2,14),new tt(4,15)),new $(26,new tt(4,13),new tt(1,14))),new et(8,Int32Array.from([6,24,42]),new $(24,new tt(2,97)),new $(22,new tt(2,38),new tt(2,39)),new $(22,new tt(4,18),new tt(2,19)),new $(26,new tt(4,14),new tt(2,15))),new et(9,Int32Array.from([6,26,46]),new $(30,new tt(2,116)),new $(22,new tt(3,36),new tt(2,37)),new $(20,new tt(4,16),new tt(4,17)),new $(24,new tt(4,12),new tt(4,13))),new et(10,Int32Array.from([6,28,50]),new $(18,new tt(2,68),new tt(2,69)),new $(26,new tt(4,43),new tt(1,44)),new $(24,new tt(6,19),new tt(2,20)),new $(28,new tt(6,15),new tt(2,16))),new et(11,Int32Array.from([6,30,54]),new $(20,new tt(4,81)),new $(30,new tt(1,50),new tt(4,51)),new $(28,new tt(4,22),new tt(4,23)),new $(24,new tt(3,12),new tt(8,13))),new et(12,Int32Array.from([6,32,58]),new $(24,new tt(2,92),new tt(2,93)),new $(22,new tt(6,36),new tt(2,37)),new $(26,new tt(4,20),new tt(6,21)),new $(28,new tt(7,14),new tt(4,15))),new et(13,Int32Array.from([6,34,62]),new $(26,new tt(4,107)),new $(22,new tt(8,37),new tt(1,38)),new $(24,new tt(8,20),new tt(4,21)),new $(22,new tt(12,11),new tt(4,12))),new et(14,Int32Array.from([6,26,46,66]),new $(30,new tt(3,115),new tt(1,116)),new $(24,new tt(4,40),new tt(5,41)),new $(20,new tt(11,16),new tt(5,17)),new $(24,new tt(11,12),new tt(5,13))),new et(15,Int32Array.from([6,26,48,70]),new $(22,new tt(5,87),new tt(1,88)),new $(24,new tt(5,41),new tt(5,42)),new $(30,new tt(5,24),new tt(7,25)),new $(24,new tt(11,12),new tt(7,13))),new et(16,Int32Array.from([6,26,50,74]),new $(24,new tt(5,98),new tt(1,99)),new $(28,new tt(7,45),new tt(3,46)),new $(24,new tt(15,19),new tt(2,20)),new $(30,new tt(3,15),new tt(13,16))),new et(17,Int32Array.from([6,30,54,78]),new $(28,new tt(1,107),new tt(5,108)),new $(28,new tt(10,46),new tt(1,47)),new $(28,new tt(1,22),new tt(15,23)),new $(28,new tt(2,14),new tt(17,15))),new et(18,Int32Array.from([6,30,56,82]),new $(30,new tt(5,120),new tt(1,121)),new $(26,new tt(9,43),new tt(4,44)),new $(28,new tt(17,22),new tt(1,23)),new $(28,new tt(2,14),new tt(19,15))),new et(19,Int32Array.from([6,30,58,86]),new $(28,new tt(3,113),new tt(4,114)),new $(26,new tt(3,44),new tt(11,45)),new $(26,new tt(17,21),new tt(4,22)),new $(26,new tt(9,13),new tt(16,14))),new et(20,Int32Array.from([6,34,62,90]),new $(28,new tt(3,107),new tt(5,108)),new $(26,new tt(3,41),new tt(13,42)),new $(30,new tt(15,24),new tt(5,25)),new $(28,new tt(15,15),new tt(10,16))),new et(21,Int32Array.from([6,28,50,72,94]),new $(28,new tt(4,116),new tt(4,117)),new $(26,new tt(17,42)),new $(28,new tt(17,22),new tt(6,23)),new $(30,new tt(19,16),new tt(6,17))),new et(22,Int32Array.from([6,26,50,74,98]),new $(28,new tt(2,111),new tt(7,112)),new $(28,new tt(17,46)),new $(30,new tt(7,24),new tt(16,25)),new $(24,new tt(34,13))),new et(23,Int32Array.from([6,30,54,78,102]),new $(30,new tt(4,121),new tt(5,122)),new $(28,new tt(4,47),new tt(14,48)),new $(30,new tt(11,24),new tt(14,25)),new $(30,new tt(16,15),new tt(14,16))),new et(24,Int32Array.from([6,28,54,80,106]),new $(30,new tt(6,117),new tt(4,118)),new $(28,new tt(6,45),new tt(14,46)),new $(30,new tt(11,24),new tt(16,25)),new $(30,new tt(30,16),new tt(2,17))),new et(25,Int32Array.from([6,32,58,84,110]),new $(26,new tt(8,106),new tt(4,107)),new $(28,new tt(8,47),new tt(13,48)),new $(30,new tt(7,24),new tt(22,25)),new $(30,new tt(22,15),new tt(13,16))),new et(26,Int32Array.from([6,30,58,86,114]),new $(28,new tt(10,114),new tt(2,115)),new $(28,new tt(19,46),new tt(4,47)),new $(28,new tt(28,22),new tt(6,23)),new $(30,new tt(33,16),new tt(4,17))),new et(27,Int32Array.from([6,34,62,90,118]),new $(30,new tt(8,122),new tt(4,123)),new $(28,new tt(22,45),new tt(3,46)),new $(30,new tt(8,23),new tt(26,24)),new $(30,new tt(12,15),new tt(28,16))),new et(28,Int32Array.from([6,26,50,74,98,122]),new $(30,new tt(3,117),new tt(10,118)),new $(28,new tt(3,45),new tt(23,46)),new $(30,new tt(4,24),new tt(31,25)),new $(30,new tt(11,15),new tt(31,16))),new et(29,Int32Array.from([6,30,54,78,102,126]),new $(30,new tt(7,116),new tt(7,117)),new $(28,new tt(21,45),new tt(7,46)),new $(30,new tt(1,23),new tt(37,24)),new $(30,new tt(19,15),new tt(26,16))),new et(30,Int32Array.from([6,26,52,78,104,130]),new $(30,new tt(5,115),new tt(10,116)),new $(28,new tt(19,47),new tt(10,48)),new $(30,new tt(15,24),new tt(25,25)),new $(30,new tt(23,15),new tt(25,16))),new et(31,Int32Array.from([6,30,56,82,108,134]),new $(30,new tt(13,115),new tt(3,116)),new $(28,new tt(2,46),new tt(29,47)),new $(30,new tt(42,24),new tt(1,25)),new $(30,new tt(23,15),new tt(28,16))),new et(32,Int32Array.from([6,34,60,86,112,138]),new $(30,new tt(17,115)),new $(28,new tt(10,46),new tt(23,47)),new $(30,new tt(10,24),new tt(35,25)),new $(30,new tt(19,15),new tt(35,16))),new et(33,Int32Array.from([6,30,58,86,114,142]),new $(30,new tt(17,115),new tt(1,116)),new $(28,new tt(14,46),new tt(21,47)),new $(30,new tt(29,24),new tt(19,25)),new $(30,new tt(11,15),new tt(46,16))),new et(34,Int32Array.from([6,34,62,90,118,146]),new $(30,new tt(13,115),new tt(6,116)),new $(28,new tt(14,46),new tt(23,47)),new $(30,new tt(44,24),new tt(7,25)),new $(30,new tt(59,16),new tt(1,17))),new et(35,Int32Array.from([6,30,54,78,102,126,150]),new $(30,new tt(12,121),new tt(7,122)),new $(28,new tt(12,47),new tt(26,48)),new $(30,new tt(39,24),new tt(14,25)),new $(30,new tt(22,15),new tt(41,16))),new et(36,Int32Array.from([6,24,50,76,102,128,154]),new $(30,new tt(6,121),new tt(14,122)),new $(28,new tt(6,47),new tt(34,48)),new $(30,new tt(46,24),new tt(10,25)),new $(30,new tt(2,15),new tt(64,16))),new et(37,Int32Array.from([6,28,54,80,106,132,158]),new $(30,new tt(17,122),new tt(4,123)),new $(28,new tt(29,46),new tt(14,47)),new $(30,new tt(49,24),new tt(10,25)),new $(30,new tt(24,15),new tt(46,16))),new et(38,Int32Array.from([6,32,58,84,110,136,162]),new $(30,new tt(4,122),new tt(18,123)),new $(28,new tt(13,46),new tt(32,47)),new $(30,new tt(48,24),new tt(14,25)),new $(30,new tt(42,15),new tt(32,16))),new et(39,Int32Array.from([6,26,54,82,110,138,166]),new $(30,new tt(20,117),new tt(4,118)),new $(28,new tt(40,47),new tt(7,48)),new $(30,new tt(43,24),new tt(22,25)),new $(30,new tt(10,15),new tt(67,16))),new et(40,Int32Array.from([6,30,58,86,114,142,170]),new $(30,new tt(19,118),new tt(6,119)),new $(28,new tt(18,47),new tt(31,48)),new $(30,new tt(34,24),new tt(34,25)),new $(30,new tt(20,15),new tt(61,16)))],function(t){t[t.DATA_MASK_000=0]="DATA_MASK_000",t[t.DATA_MASK_001=1]="DATA_MASK_001",t[t.DATA_MASK_010=2]="DATA_MASK_010",t[t.DATA_MASK_011=3]="DATA_MASK_011",t[t.DATA_MASK_100=4]="DATA_MASK_100",t[t.DATA_MASK_101=5]="DATA_MASK_101",t[t.DATA_MASK_110=6]="DATA_MASK_110",t[t.DATA_MASK_111=7]="DATA_MASK_111"}(V||(V={}));class rt{constructor(t,e){this.value=t,this.isMasked=e}unmaskBitMatrix(t,e){for(let r=0;r<e;r++)for(let n=0;n<e;n++)this.isMasked(r,n)&&t.flip(n,r)}}rt.values=new Map([[V.DATA_MASK_000,new rt(V.DATA_MASK_000,((t,e)=>!(t+e&1)))],[V.DATA_MASK_001,new rt(V.DATA_MASK_001,((t,e)=>!(1&t)))],[V.DATA_MASK_010,new rt(V.DATA_MASK_010,((t,e)=>e%3==0))],[V.DATA_MASK_011,new rt(V.DATA_MASK_011,((t,e)=>(t+e)%3==0))],[V.DATA_MASK_100,new rt(V.DATA_MASK_100,((t,e)=>!(Math.floor(t/2)+Math.floor(e/3)&1)))],[V.DATA_MASK_101,new rt(V.DATA_MASK_101,((t,e)=>t*e%6==0))],[V.DATA_MASK_110,new rt(V.DATA_MASK_110,((t,e)=>t*e%6<3))],[V.DATA_MASK_111,new rt(V.DATA_MASK_111,((t,e)=>!(t+e+t*e%3&1)))]]);class nt{constructor(t){const e=t.getHeight();if(e<21||1!=(3&e))throw new p;this.bitMatrix=t}readFormatInformation(){if(null!==this.parsedFormatInfo&&void 0!==this.parsedFormatInfo)return this.parsedFormatInfo;let t=0;for(let e=0;e<6;e++)t=this.copyBit(e,8,t);t=this.copyBit(7,8,t),t=this.copyBit(8,8,t),t=this.copyBit(8,7,t);for(let e=5;e>=0;e--)t=this.copyBit(8,e,t);const e=this.bitMatrix.getHeight();let r=0;const n=e-7;for(let t=e-1;t>=n;t--)r=this.copyBit(8,t,r);for(let t=e-8;t<e;t++)r=this.copyBit(t,8,r);if(this.parsedFormatInfo=j.decodeFormatInformation(t,r),null!==this.parsedFormatInfo)return this.parsedFormatInfo;throw new p}readVersion(){if(null!==this.parsedVersion&&void 0!==this.parsedVersion)return this.parsedVersion;const t=this.bitMatrix.getHeight(),e=Math.floor((t-17)/4);if(e<=6)return et.getVersionForNumber(e);let r=0;const n=t-11;for(let e=5;e>=0;e--)for(let i=t-9;i>=n;i--)r=this.copyBit(i,e,r);let i=et.decodeVersionInformation(r);if(null!==i&&i.getDimensionForVersion()===t)return this.parsedVersion=i,i;r=0;for(let e=5;e>=0;e--)for(let i=t-9;i>=n;i--)r=this.copyBit(e,i,r);if(i=et.decodeVersionInformation(r),null!==i&&i.getDimensionForVersion()===t)return this.parsedVersion=i,i;throw new p}copyBit(t,e,r){return(this.isMirror?this.bitMatrix.get(e,t):this.bitMatrix.get(t,e))?r<<1|1:r<<1}readCodewords(){const t=this.readFormatInformation(),e=this.readVersion(),r=rt.values.get(t.getDataMask()),n=this.bitMatrix.getHeight();r.unmaskBitMatrix(this.bitMatrix,n);const i=e.buildFunctionPattern();let s=!0;const o=new Uint8Array(e.getTotalCodewords());let a=0,h=0,l=0;for(let t=n-1;t>0;t-=2){6===t&&t--;for(let e=0;e<n;e++){const r=s?n-1-e:e;for(let e=0;e<2;e++)i.get(t-e,r)||(l++,h<<=1,this.bitMatrix.get(t-e,r)&&(h|=1),8===l&&(o[a++]=h,l=0,h=0))}s=!s}if(a!==e.getTotalCodewords())throw new p;return o}remask(){if(null===this.parsedFormatInfo)return;const t=rt.values.get(this.parsedFormatInfo.getDataMask()),e=this.bitMatrix.getHeight();t.unmaskBitMatrix(this.bitMatrix,e)}setMirror(t){this.parsedVersion=null,this.parsedFormatInfo=null,this.isMirror=t}mirror(){const t=this.bitMatrix;for(let e=0,r=t.getWidth();e<r;e++)for(let r=e+1,n=t.getHeight();r<n;r++)t.get(e,r)!==t.get(r,e)&&(t.flip(r,e),t.flip(e,r))}}class it{constructor(t,e){this.numDataCodewords=t,this.codewords=e}static getDataBlocks(t,e,r){if(t.length!==e.getTotalCodewords())throw new a;const n=e.getECBlocksForLevel(r);let i=0;const s=n.getECBlocks();for(const t of s)i+=t.getCount();const o=new Array(i);let h=0;for(const t of s)for(let e=0;e<t.getCount();e++){const e=t.getDataCodewords(),r=n.getECCodewordsPerBlock()+e;o[h++]=new it(e,new Uint8Array(r))}const l=o[0].codewords.length;let c=o.length-1;for(;c>=0;){if(o[c].codewords.length===l)break;c--}c++;const d=l-n.getECCodewordsPerBlock();let u=0;for(let e=0;e<d;e++)for(let r=0;r<h;r++)o[r].codewords[e]=t[u++];for(let e=c;e<h;e++)o[e].codewords[d]=t[u++];const f=o[0].codewords.length;for(let e=d;e<f;e++)for(let r=0;r<h;r++){const n=r<c?e:e+1;o[r].codewords[n]=t[u++]}return o}getNumDataCodewords(){return this.numDataCodewords}getCodewords(){return this.codewords}}class st{constructor(t){this.bytes=t,this.byteOffset=0,this.bitOffset=0}getBitOffset(){return this.bitOffset}getByteOffset(){return this.byteOffset}readBits(t){if(t<1||t>32||t>this.available())throw new a(""+t);let e=0,r=this.bitOffset,n=this.byteOffset;const i=this.bytes;if(r>0){const s=8-r,o=t<s?t:s,a=s-o,h=255>>8-o<<a;e=(i[n]&h)>>a,t-=o,r+=o,8===r&&(r=0,n++)}if(t>0){for(;t>=8;)e=e<<8|255&i[n],n++,t-=8;if(t>0){const s=8-t,o=255>>s<<s;e=e<<t|(i[n]&o)>>s,r+=t}}return this.bitOffset=r,this.byteOffset=n,e}available(){return 8*(this.bytes.length-this.byteOffset)-this.bitOffset}}class ot{constructor(t,e,r,n,i=-1,s=-1){this.rawBytes=t,this.text=e,this.byteSegments=r,this.ecLevel=n,this.structuredAppendSequenceNumber=i,this.structuredAppendParity=s,this.numBits=null==t?0:8*t.length}getRawBytes(){return this.rawBytes}getNumBits(){return this.numBits}setNumBits(t){this.numBits=t}getText(){return this.text}getByteSegments(){return this.byteSegments}getECLevel(){return this.ecLevel}getErrorsCorrected(){return this.errorsCorrected}setErrorsCorrected(t){this.errorsCorrected=t}getErasures(){return this.erasures}setErasures(t){this.erasures=t}getOther(){return this.other}setOther(t){this.other=t}hasStructuredAppend(){return this.structuredAppendParity>=0&&this.structuredAppendSequenceNumber>=0}getStructuredAppendParity(){return this.structuredAppendParity}getStructuredAppendSequenceNumber(){return this.structuredAppendSequenceNumber}}!function(t){t[t.TERMINATOR=0]="TERMINATOR",t[t.NUMERIC=1]="NUMERIC",t[t.ALPHANUMERIC=2]="ALPHANUMERIC",t[t.STRUCTURED_APPEND=3]="STRUCTURED_APPEND",t[t.BYTE=4]="BYTE",t[t.ECI=5]="ECI",t[t.KANJI=6]="KANJI",t[t.FNC1_FIRST_POSITION=7]="FNC1_FIRST_POSITION",t[t.FNC1_SECOND_POSITION=8]="FNC1_SECOND_POSITION",t[t.HANZI=9]="HANZI"}(z||(z={}));class at{constructor(t,e,r,n){this.value=t,this.stringValue=e,this.characterCountBitsForVersions=r,this.bits=n,at.FOR_BITS.set(n,this),at.FOR_VALUE.set(t,this)}static forBits(t){const e=at.FOR_BITS.get(t);if(void 0===e)throw new a;return e}getCharacterCountBits(t){const e=t.getVersionNumber();let r;return r=e<=9?0:e<=26?1:2,this.characterCountBitsForVersions[r]}getValue(){return this.value}getBits(){return this.bits}equals(t){if(!(t instanceof at))return!1;const e=t;return this.value===e.value}toString(){return this.stringValue}}at.FOR_BITS=new Map,at.FOR_VALUE=new Map,at.TERMINATOR=new at(z.TERMINATOR,"TERMINATOR",Int32Array.from([0,0,0]),0),at.NUMERIC=new at(z.NUMERIC,"NUMERIC",Int32Array.from([10,12,14]),1),at.ALPHANUMERIC=new at(z.ALPHANUMERIC,"ALPHANUMERIC",Int32Array.from([9,11,13]),2),at.STRUCTURED_APPEND=new at(z.STRUCTURED_APPEND,"STRUCTURED_APPEND",Int32Array.from([0,0,0]),3),at.BYTE=new at(z.BYTE,"BYTE",Int32Array.from([8,16,16]),4),at.ECI=new at(z.ECI,"ECI",Int32Array.from([0,0,0]),7),at.KANJI=new at(z.KANJI,"KANJI",Int32Array.from([8,10,12]),8),at.FNC1_FIRST_POSITION=new at(z.FNC1_FIRST_POSITION,"FNC1_FIRST_POSITION",Int32Array.from([0,0,0]),5),at.FNC1_SECOND_POSITION=new at(z.FNC1_SECOND_POSITION,"FNC1_SECOND_POSITION",Int32Array.from([0,0,0]),9),at.HANZI=new at(z.HANZI,"HANZI",Int32Array.from([8,10,12]),13);class ht{static decode(t,e,r,n){const i=new st(t);let s=new y;const o=new Array;let a=-1,h=-1;try{let t,r=null,l=!1;do{if(i.available()<4)t=at.TERMINATOR;else{const e=i.readBits(4);t=at.forBits(e)}switch(t){case at.TERMINATOR:break;case at.FNC1_FIRST_POSITION:case at.FNC1_SECOND_POSITION:l=!0;break;case at.STRUCTURED_APPEND:if(i.available()<16)throw new p;a=i.readBits(8),h=i.readBits(8);break;case at.ECI:const c=ht.parseECIValue(i);if(r=E.getCharacterSetECIByValue(c),null===r)throw new p;break;case at.HANZI:const d=i.readBits(4),u=i.readBits(t.getCharacterCountBits(e));d===ht.GB2312_SUBSET&&ht.decodeHanziSegment(i,s,u);break;default:const f=i.readBits(t.getCharacterCountBits(e));switch(t){case at.NUMERIC:ht.decodeNumericSegment(i,s,f);break;case at.ALPHANUMERIC:ht.decodeAlphanumericSegment(i,s,f,l);break;case at.BYTE:ht.decodeByteSegment(i,s,f,r,o,n);break;case at.KANJI:ht.decodeKanjiSegment(i,s,f);break;default:throw new p}}}while(t!==at.TERMINATOR)}catch(t){throw new p}return new ot(t,s.toString(),0===o.length?null:o,null===r?null:r.toString(),a,h)}static decodeHanziSegment(t,e,r){if(13*r>t.available())throw new p;const n=new Uint8Array(2*r);let i=0;for(;r>0;){const e=t.readBits(13);let s=e/96<<8&4294967295|e%96;s+=s<959?41377:42657,n[i]=s>>8&255,n[i+1]=255&s,i+=2,r--}try{e.append(C.decode(n,_.GB2312))}catch(t){throw new p(t)}}static decodeKanjiSegment(t,e,r){if(13*r>t.available())throw new p;const n=new Uint8Array(2*r);let i=0;for(;r>0;){const e=t.readBits(13);let s=e/192<<8&4294967295|e%192;s+=s<7936?33088:49472,n[i]=s>>8,n[i+1]=s,i+=2,r--}try{e.append(C.decode(n,_.SHIFT_JIS))}catch(t){throw new p(t)}}static decodeByteSegment(t,e,r,n,i,s){if(8*r>t.available())throw new p;const o=new Uint8Array(r);for(let e=0;e<r;e++)o[e]=t.readBits(8);let a;a=null===n?_.guessEncoding(o,s):n.getName();try{e.append(C.decode(o,a))}catch(t){throw new p(t)}i.push(o)}static toAlphaNumericChar(t){if(t>=ht.ALPHANUMERIC_CHARS.length)throw new p;return ht.ALPHANUMERIC_CHARS[t]}static decodeAlphanumericSegment(t,e,r,n){const i=e.length();for(;r>1;){if(t.available()<11)throw new p;const n=t.readBits(11);e.append(ht.toAlphaNumericChar(Math.floor(n/45))),e.append(ht.toAlphaNumericChar(n%45)),r-=2}if(1===r){if(t.available()<6)throw new p;e.append(ht.toAlphaNumericChar(t.readBits(6)))}if(n)for(let t=i;t<e.length();t++)"%"===e.charAt(t)&&(t<e.length()-1&&"%"===e.charAt(t+1)?e.deleteCharAt(t+1):e.setCharAt(t,String.fromCharCode(29)))}static decodeNumericSegment(t,e,r){for(;r>=3;){if(t.available()<10)throw new p;const n=t.readBits(10);if(n>=1e3)throw new p;e.append(ht.toAlphaNumericChar(Math.floor(n/100))),e.append(ht.toAlphaNumericChar(Math.floor(n/10)%10)),e.append(ht.toAlphaNumericChar(n%10)),r-=3}if(2===r){if(t.available()<7)throw new p;const r=t.readBits(7);if(r>=100)throw new p;e.append(ht.toAlphaNumericChar(Math.floor(r/10))),e.append(ht.toAlphaNumericChar(r%10))}else if(1===r){if(t.available()<4)throw new p;const r=t.readBits(4);if(r>=10)throw new p;e.append(ht.toAlphaNumericChar(r))}}static parseECIValue(t){const e=t.readBits(8);if(!(128&e))return 127&e;if(128==(192&e)){return(63&e)<<8&4294967295|t.readBits(8)}if(192==(224&e)){return(31&e)<<16&4294967295|t.readBits(16)}throw new p}}ht.ALPHANUMERIC_CHARS="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:",ht.GB2312_SUBSET=1;class lt{constructor(t){this.mirrored=t}isMirrored(){return this.mirrored}applyMirroredCorrection(t){if(!this.mirrored||null===t||t.length<3)return;const e=t[0];t[0]=t[2],t[2]=e}}class ct{constructor(){this.rsDecoder=new q(X.QR_CODE_FIELD_256)}decodeBooleanArray(t,e){return this.decodeBitMatrix(M.parseFromBooleanArray(t),e)}decodeBitMatrix(t,e){const r=new nt(t);let n=null;try{return this.decodeBitMatrixParser(r,e)}catch(t){n=t}try{r.remask(),r.setMirror(!0),r.readVersion(),r.readFormatInformation(),r.mirror();const t=this.decodeBitMatrixParser(r,e);return t.setOther(new lt(!0)),t}catch(t){if(null!==n)throw n;throw t}}decodeBitMatrixParser(t,e){const r=t.readVersion(),n=t.readFormatInformation().getErrorCorrectionLevel(),i=t.readCodewords(),s=it.getDataBlocks(i,r,n);let o=0;for(const t of s)o+=t.getNumDataCodewords();const a=new Uint8Array(o);let h=0;for(const t of s){const e=t.getCodewords(),r=t.getNumDataCodewords();this.correctErrors(e,r);for(let t=0;t<r;t++)a[h++]=e[t]}return ht.decode(a,r,n,e)}correctErrors(t,e){const r=new Int32Array(t);try{this.rsDecoder.decode(r,t.length-e)}catch(t){throw new l}for(let n=0;n<e;n++)t[n]=r[n]}}class dt{constructor(){}static round(t){return isNaN(t)?0:t<=Number.MIN_SAFE_INTEGER?Number.MIN_SAFE_INTEGER:t>=Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:t+(t<0?-.5:.5)|0}static distance(t,e,r,n){const i=t-r,s=e-n;return Math.sqrt(i*i+s*s)}static sum(t){let e=0;for(let r=0,n=t.length;r!==n;r++){e+=t[r]}return e}}class ut{constructor(t,e){this.bits=t,this.points=e}getBits(){return this.bits}getPoints(){return this.points}}class ft{static checkAndNudgePoints(t,e){const r=t.getWidth(),n=t.getHeight();let i=!0;for(let t=0;t<e.length&&i;t+=2){const s=Math.floor(e[t]),o=Math.floor(e[t+1]);if(s<-1||s>r||o<-1||o>n)throw new O;i=!1,-1===s?(e[t]=0,i=!0):s===r&&(e[t]=r-1,i=!0),-1===o?(e[t+1]=0,i=!0):o===n&&(e[t+1]=n-1,i=!0)}i=!0;for(let t=e.length-2;t>=0&&i;t-=2){const s=Math.floor(e[t]),o=Math.floor(e[t+1]);if(s<-1||s>r||o<-1||o>n)throw new O;i=!1,-1===s?(e[t]=0,i=!0):s===r&&(e[t]=r-1,i=!0),-1===o?(e[t+1]=0,i=!0):o===n&&(e[t+1]=n-1,i=!0)}}}class wt{constructor(t,e,r,n,i,s,o,a,h){this.a11=t,this.a21=e,this.a31=r,this.a12=n,this.a22=i,this.a32=s,this.a13=o,this.a23=a,this.a33=h}static quadrilateralToQuadrilateral(t,e,r,n,i,s,o,a,h,l,c,d,u,f,w,g){const m=wt.quadrilateralToSquare(t,e,r,n,i,s,o,a);return wt.squareToQuadrilateral(h,l,c,d,u,f,w,g).times(m)}transformPoints(t){const e=t.length,r=this.a11,n=this.a12,i=this.a13,s=this.a21,o=this.a22,a=this.a23,h=this.a31,l=this.a32,c=this.a33;for(let d=0;d<e;d+=2){const e=t[d],u=t[d+1],f=i*e+a*u+c;t[d]=(r*e+s*u+h)/f,t[d+1]=(n*e+o*u+l)/f}}transformPointsWithValues(t,e){const r=this.a11,n=this.a12,i=this.a13,s=this.a21,o=this.a22,a=this.a23,h=this.a31,l=this.a32,c=this.a33,d=t.length;for(let u=0;u<d;u++){const d=t[u],f=e[u],w=i*d+a*f+c;t[u]=(r*d+s*f+h)/w,e[u]=(n*d+o*f+l)/w}}static squareToQuadrilateral(t,e,r,n,i,s,o,a){const h=t-r+i-o,l=e-n+s-a;if(0===h&&0===l)return new wt(r-t,i-r,t,n-e,s-n,e,0,0,1);{const c=r-i,d=o-i,u=n-s,f=a-s,w=c*f-d*u,g=(h*f-d*l)/w,m=(c*l-h*u)/w;return new wt(r-t+g*r,o-t+m*o,t,n-e+g*n,a-e+m*a,e,g,m,1)}}static quadrilateralToSquare(t,e,r,n,i,s,o,a){return wt.squareToQuadrilateral(t,e,r,n,i,s,o,a).buildAdjoint()}buildAdjoint(){return new wt(this.a22*this.a33-this.a23*this.a32,this.a23*this.a31-this.a21*this.a33,this.a21*this.a32-this.a22*this.a31,this.a13*this.a32-this.a12*this.a33,this.a11*this.a33-this.a13*this.a31,this.a12*this.a31-this.a11*this.a32,this.a12*this.a23-this.a13*this.a22,this.a13*this.a21-this.a11*this.a23,this.a11*this.a22-this.a12*this.a21)}times(t){return new wt(this.a11*t.a11+this.a21*t.a12+this.a31*t.a13,this.a11*t.a21+this.a21*t.a22+this.a31*t.a23,this.a11*t.a31+this.a21*t.a32+this.a31*t.a33,this.a12*t.a11+this.a22*t.a12+this.a32*t.a13,this.a12*t.a21+this.a22*t.a22+this.a32*t.a23,this.a12*t.a31+this.a22*t.a32+this.a32*t.a33,this.a13*t.a11+this.a23*t.a12+this.a33*t.a13,this.a13*t.a21+this.a23*t.a22+this.a33*t.a23,this.a13*t.a31+this.a23*t.a32+this.a33*t.a33)}}class gt{static setGridSampler(t){gt.gridSampler=t}static getInstance(){return gt.gridSampler}}gt.gridSampler=new class extends ft{sampleGrid(t,e,r,n,i,s,o,a,h,l,c,d,u,f,w,g,m,I,A){const p=wt.quadrilateralToQuadrilateral(n,i,s,o,a,h,l,c,d,u,f,w,g,m,I,A);return this.sampleGridWithTransform(t,e,r,p)}sampleGridWithTransform(t,e,r,n){if(e<=0||r<=0)throw new O;const i=new M(e,r),s=new Float32Array(2*e);for(let e=0;e<r;e++){const r=s.length,o=e+.5;for(let t=0;t<r;t+=2)s[t]=t/2+.5,s[t+1]=o;n.transformPoints(s),ft.checkAndNudgePoints(t,s);try{for(let n=0;n<r;n+=2)t.get(Math.floor(s[n]),Math.floor(s[n+1]))&&i.set(n/2,e)}catch(t){throw new O}}return i}};class mt{static floatToIntBits(t){return t}}mt.MAX_VALUE=Number.MAX_SAFE_INTEGER;class It{constructor(t,e){this.x=t,this.y=e}getX(){return this.x}getY(){return this.y}equals(t){if(t instanceof It){const e=t;return this.x===e.x&&this.y===e.y}return!1}hashCode(){return 31*mt.floatToIntBits(this.x)+mt.floatToIntBits(this.y)}toString(){return"("+this.x+","+this.y+")"}static orderBestPatterns(t){const e=this.distance(t[0],t[1]),r=this.distance(t[1],t[2]),n=this.distance(t[0],t[2]);let i,s,o;if(r>=e&&r>=n?(s=t[0],i=t[1],o=t[2]):n>=r&&n>=e?(s=t[1],i=t[0],o=t[2]):(s=t[2],i=t[0],o=t[1]),this.crossProductZ(i,s,o)<0){const t=i;i=o,o=t}t[0]=i,t[1]=s,t[2]=o}static distance(t,e){return dt.distance(t.x,t.y,e.x,e.y)}static crossProductZ(t,e,r){const n=e.x,i=e.y;return(r.x-n)*(t.y-i)-(r.y-i)*(t.x-n)}}class At extends It{constructor(t,e,r){super(t,e),this.estimatedModuleSize=r}aboutEquals(t,e,r){if(Math.abs(e-this.getY())<=t&&Math.abs(r-this.getX())<=t){const e=Math.abs(t-this.estimatedModuleSize);return e<=1||e<=this.estimatedModuleSize}return!1}combineEstimate(t,e,r){const n=(this.getX()+e)/2,i=(this.getY()+t)/2,s=(this.estimatedModuleSize+r)/2;return new At(n,i,s)}}class pt{constructor(t,e,r,n,i,s,o){this.image=t,this.startX=e,this.startY=r,this.width=n,this.height=i,this.moduleSize=s,this.resultPointCallback=o,this.possibleCenters=[],this.crossCheckStateCount=new Int32Array(3)}find(){const t=this.startX,e=this.height,r=t+this.width,n=this.startY+e/2,i=new Int32Array(3),s=this.image;for(let o=0;o<e;o++){const e=n+(1&o?-Math.floor((o+1)/2):Math.floor((o+1)/2));i[0]=0,i[1]=0,i[2]=0;let a=t;for(;a<r&&!s.get(a,e);)a++;let h=0;for(;a<r;){if(s.get(a,e))if(1===h)i[1]++;else if(2===h){if(this.foundPatternCross(i)){const t=this.handlePossibleCenter(i,e,a);if(null!==t)return t}i[0]=i[2],i[1]=1,i[2]=0,h=1}else i[++h]++;else 1===h&&h++,i[h]++;a++}if(this.foundPatternCross(i)){const t=this.handlePossibleCenter(i,e,r);if(null!==t)return t}}if(0!==this.possibleCenters.length)return this.possibleCenters[0];throw new O}static centerFromEnd(t,e){return e-t[2]-t[1]/2}foundPatternCross(t){const e=this.moduleSize,r=e/2;for(let n=0;n<3;n++)if(Math.abs(e-t[n])>=r)return!1;return!0}crossCheckVertical(t,e,r,n){const i=this.image,s=i.getHeight(),o=this.crossCheckStateCount;o[0]=0,o[1]=0,o[2]=0;let a=t;for(;a>=0&&i.get(e,a)&&o[1]<=r;)o[1]++,a--;if(a<0||o[1]>r)return NaN;for(;a>=0&&!i.get(e,a)&&o[0]<=r;)o[0]++,a--;if(o[0]>r)return NaN;for(a=t+1;a<s&&i.get(e,a)&&o[1]<=r;)o[1]++,a++;if(a===s||o[1]>r)return NaN;for(;a<s&&!i.get(e,a)&&o[2]<=r;)o[2]++,a++;if(o[2]>r)return NaN;const h=o[0]+o[1]+o[2];return 5*Math.abs(h-n)>=2*n?NaN:this.foundPatternCross(o)?pt.centerFromEnd(o,a):NaN}handlePossibleCenter(t,e,r){const n=t[0]+t[1]+t[2],i=pt.centerFromEnd(t,r),s=this.crossCheckVertical(e,i,2*t[1],n);if(!isNaN(s)){const e=(t[0]+t[1]+t[2])/3;for(const t of this.possibleCenters)if(t.aboutEquals(e,s,i))return t.combineEstimate(s,i,e);const r=new At(i,s,e);this.possibleCenters.push(r),null!==this.resultPointCallback&&void 0!==this.resultPointCallback&&this.resultPointCallback.foundPossibleResultPoint(r)}return null}}class Et extends It{constructor(t,e,r,n){super(t,e),this.estimatedModuleSize=r,this.count=n,void 0===n&&(this.count=1)}getEstimatedModuleSize(){return this.estimatedModuleSize}getCount(){return this.count}aboutEquals(t,e,r){if(Math.abs(e-this.getY())<=t&&Math.abs(r-this.getX())<=t){const e=Math.abs(t-this.estimatedModuleSize);return e<=1||e<=this.estimatedModuleSize}return!1}combineEstimate(t,e,r){const n=this.count+1,i=(this.count*this.getX()+e)/n,s=(this.count*this.getY()+t)/n,o=(this.count*this.estimatedModuleSize+r)/n;return new Et(i,s,o,n)}}class St{constructor(t){this.bottomLeft=t[0],this.topLeft=t[1],this.topRight=t[2]}getBottomLeft(){return this.bottomLeft}getTopLeft(){return this.topLeft}getTopRight(){return this.topRight}}class Ct{constructor(t,e){this.image=t,this.resultPointCallback=e,this.possibleCenters=[],this.crossCheckStateCount=new Int32Array(5),this.resultPointCallback=e}getImage(){return this.image}getPossibleCenters(){return this.possibleCenters}find(t){const e=null!=t&&void 0!==t.get(A.TRY_HARDER),r=null!=t&&void 0!==t.get(A.PURE_BARCODE),n=this.image,i=n.getHeight(),s=n.getWidth();let o=Math.floor(3*i/(4*Ct.MAX_MODULES));(o<Ct.MIN_SKIP||e)&&(o=Ct.MIN_SKIP);let a=!1;const h=new Int32Array(5);for(let t=o-1;t<i&&!a;t+=o){h[0]=0,h[1]=0,h[2]=0,h[3]=0,h[4]=0;let e=0;for(let i=0;i<s;i++)if(n.get(i,t))1&~e||e++,h[e]++;else if(1&e)h[e]++;else if(4===e)if(Ct.foundPatternCross(h)){if(!0!==this.handlePossibleCenter(h,t,i,r)){h[0]=h[2],h[1]=h[3],h[2]=h[4],h[3]=1,h[4]=0,e=3;continue}if(o=2,!0===this.hasSkipped)a=this.haveMultiplyConfirmedCenters();else{const e=this.findRowSkip();e>h[2]&&(t+=e-h[2]-o,i=s-1)}e=0,h[0]=0,h[1]=0,h[2]=0,h[3]=0,h[4]=0}else h[0]=h[2],h[1]=h[3],h[2]=h[4],h[3]=1,h[4]=0,e=3;else h[++e]++;if(Ct.foundPatternCross(h)){!0===this.handlePossibleCenter(h,t,s,r)&&(o=h[0],this.hasSkipped&&(a=this.haveMultiplyConfirmedCenters()))}}const l=this.selectBestPatterns();return It.orderBestPatterns(l),new St(l)}static centerFromEnd(t,e){return e-t[4]-t[3]-t[2]/2}static foundPatternCross(t){let e=0;for(let r=0;r<5;r++){const n=t[r];if(0===n)return!1;e+=n}if(e<7)return!1;const r=e/7,n=r/2;return Math.abs(r-t[0])<n&&Math.abs(r-t[1])<n&&Math.abs(3*r-t[2])<3*n&&Math.abs(r-t[3])<n&&Math.abs(r-t[4])<n}getCrossCheckStateCount(){const t=this.crossCheckStateCount;return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t}crossCheckDiagonal(t,e,r,n){const i=this.getCrossCheckStateCount();let s=0;const o=this.image;for(;t>=s&&e>=s&&o.get(e-s,t-s);)i[2]++,s++;if(t<s||e<s)return!1;for(;t>=s&&e>=s&&!o.get(e-s,t-s)&&i[1]<=r;)i[1]++,s++;if(t<s||e<s||i[1]>r)return!1;for(;t>=s&&e>=s&&o.get(e-s,t-s)&&i[0]<=r;)i[0]++,s++;if(i[0]>r)return!1;const a=o.getHeight(),h=o.getWidth();for(s=1;t+s<a&&e+s<h&&o.get(e+s,t+s);)i[2]++,s++;if(t+s>=a||e+s>=h)return!1;for(;t+s<a&&e+s<h&&!o.get(e+s,t+s)&&i[3]<r;)i[3]++,s++;if(t+s>=a||e+s>=h||i[3]>=r)return!1;for(;t+s<a&&e+s<h&&o.get(e+s,t+s)&&i[4]<r;)i[4]++,s++;if(i[4]>=r)return!1;const l=i[0]+i[1]+i[2]+i[3]+i[4];return Math.abs(l-n)<2*n&&Ct.foundPatternCross(i)}crossCheckVertical(t,e,r,n){const i=this.image,s=i.getHeight(),o=this.getCrossCheckStateCount();let a=t;for(;a>=0&&i.get(e,a);)o[2]++,a--;if(a<0)return NaN;for(;a>=0&&!i.get(e,a)&&o[1]<=r;)o[1]++,a--;if(a<0||o[1]>r)return NaN;for(;a>=0&&i.get(e,a)&&o[0]<=r;)o[0]++,a--;if(o[0]>r)return NaN;for(a=t+1;a<s&&i.get(e,a);)o[2]++,a++;if(a===s)return NaN;for(;a<s&&!i.get(e,a)&&o[3]<r;)o[3]++,a++;if(a===s||o[3]>=r)return NaN;for(;a<s&&i.get(e,a)&&o[4]<r;)o[4]++,a++;if(o[4]>=r)return NaN;const h=o[0]+o[1]+o[2]+o[3]+o[4];return 5*Math.abs(h-n)>=2*n?NaN:Ct.foundPatternCross(o)?Ct.centerFromEnd(o,a):NaN}crossCheckHorizontal(t,e,r,n){const i=this.image,s=i.getWidth(),o=this.getCrossCheckStateCount();let a=t;for(;a>=0&&i.get(a,e);)o[2]++,a--;if(a<0)return NaN;for(;a>=0&&!i.get(a,e)&&o[1]<=r;)o[1]++,a--;if(a<0||o[1]>r)return NaN;for(;a>=0&&i.get(a,e)&&o[0]<=r;)o[0]++,a--;if(o[0]>r)return NaN;for(a=t+1;a<s&&i.get(a,e);)o[2]++,a++;if(a===s)return NaN;for(;a<s&&!i.get(a,e)&&o[3]<r;)o[3]++,a++;if(a===s||o[3]>=r)return NaN;for(;a<s&&i.get(a,e)&&o[4]<r;)o[4]++,a++;if(o[4]>=r)return NaN;const h=o[0]+o[1]+o[2]+o[3]+o[4];return 5*Math.abs(h-n)>=n?NaN:Ct.foundPatternCross(o)?Ct.centerFromEnd(o,a):NaN}handlePossibleCenter(t,e,r,n){const i=t[0]+t[1]+t[2]+t[3]+t[4];let s=Ct.centerFromEnd(t,r),o=this.crossCheckVertical(e,Math.floor(s),t[2],i);if(!isNaN(o)&&(s=this.crossCheckHorizontal(Math.floor(s),Math.floor(o),t[2],i),!isNaN(s)&&(!n||this.crossCheckDiagonal(Math.floor(o),Math.floor(s),t[2],i)))){const t=i/7;let e=!1;const r=this.possibleCenters;for(let n=0,i=r.length;n<i;n++){const i=r[n];if(i.aboutEquals(t,o,s)){r[n]=i.combineEstimate(o,s,t),e=!0;break}}if(!e){const e=new Et(s,o,t);r.push(e),null!==this.resultPointCallback&&void 0!==this.resultPointCallback&&this.resultPointCallback.foundPossibleResultPoint(e)}return!0}return!1}findRowSkip(){if(this.possibleCenters.length<=1)return 0;let t=null;for(const e of this.possibleCenters)if(e.getCount()>=Ct.CENTER_QUORUM){if(null!=t)return this.hasSkipped=!0,Math.floor((Math.abs(t.getX()-e.getX())-Math.abs(t.getY()-e.getY()))/2);t=e}return 0}haveMultiplyConfirmedCenters(){let t=0,e=0;const r=this.possibleCenters.length;for(const r of this.possibleCenters)r.getCount()>=Ct.CENTER_QUORUM&&(t++,e+=r.getEstimatedModuleSize());if(t<3)return!1;const n=e/r;let i=0;for(const t of this.possibleCenters)i+=Math.abs(t.getEstimatedModuleSize()-n);return i<=.05*e}selectBestPatterns(){const t=this.possibleCenters.length;if(t<3)throw new O;const e=this.possibleCenters;let r;if(t>3){let n=0,i=0;for(const t of this.possibleCenters){const e=t.getEstimatedModuleSize();n+=e,i+=e*e}r=n/t;let s=Math.sqrt(i/t-r*r);e.sort(((t,e)=>{const n=Math.abs(e.getEstimatedModuleSize()-r),i=Math.abs(t.getEstimatedModuleSize()-r);return n<i?-1:n>i?1:0}));const o=Math.max(.2*r,s);for(let t=0;t<e.length&&e.length>3;t++){const n=e[t];Math.abs(n.getEstimatedModuleSize()-r)>o&&(e.splice(t,1),t--)}}if(e.length>3){let t=0;for(const r of e)t+=r.getEstimatedModuleSize();r=t/e.length,e.sort(((t,e)=>{if(e.getCount()===t.getCount()){const n=Math.abs(e.getEstimatedModuleSize()-r),i=Math.abs(t.getEstimatedModuleSize()-r);return n<i?1:n>i?-1:0}return e.getCount()-t.getCount()})),e.splice(3)}return[e[0],e[1],e[2]]}}Ct.CENTER_QUORUM=2,Ct.MIN_SKIP=3,Ct.MAX_MODULES=57;class _t{constructor(t){this.image=t}getImage(){return this.image}getResultPointCallback(){return this.resultPointCallback}detect(t){this.resultPointCallback=null==t?null:t.get(A.NEED_RESULT_POINT_CALLBACK);const e=new Ct(this.image,this.resultPointCallback).find(t);return this.processFinderPatternInfo(e)}processFinderPatternInfo(t){const e=t.getTopLeft(),r=t.getTopRight(),n=t.getBottomLeft(),i=this.calculateModuleSize(e,r,n);if(i<1)throw new O("No pattern found in proccess finder.");const s=_t.computeDimension(e,r,n,i),o=et.getProvisionalVersionForDimension(s),a=o.getDimensionForVersion()-7;let h=null;if(o.getAlignmentPatternCenters().length>0){const t=r.getX()-e.getX()+n.getX(),s=r.getY()-e.getY()+n.getY(),o=1-3/a,l=Math.floor(e.getX()+o*(t-e.getX())),c=Math.floor(e.getY()+o*(s-e.getY()));for(let t=4;t<=16;t<<=1)try{h=this.findAlignmentInRegion(i,l,c,t);break}catch(t){if(!(t instanceof O))throw t}}const l=_t.createTransform(e,r,n,h,s),c=_t.sampleGrid(this.image,l,s);let d;return d=null===h?[n,e,r]:[n,e,r,h],new ut(c,d)}static createTransform(t,e,r,n,i){const s=i-3.5;let o,a,h,l;return null!==n?(o=n.getX(),a=n.getY(),h=s-3,l=h):(o=e.getX()-t.getX()+r.getX(),a=e.getY()-t.getY()+r.getY(),h=s,l=s),wt.quadrilateralToQuadrilateral(3.5,3.5,s,3.5,h,l,3.5,s,t.getX(),t.getY(),e.getX(),e.getY(),o,a,r.getX(),r.getY())}static sampleGrid(t,e,r){return gt.getInstance().sampleGridWithTransform(t,r,r,e)}static computeDimension(t,e,r,n){const i=dt.round(It.distance(t,e)/n),s=dt.round(It.distance(t,r)/n);let o=Math.floor((i+s)/2)+7;switch(3&o){case 0:o++;break;case 2:o--;break;case 3:throw new O("Dimensions could be not found.")}return o}calculateModuleSize(t,e,r){return(this.calculateModuleSizeOneWay(t,e)+this.calculateModuleSizeOneWay(t,r))/2}calculateModuleSizeOneWay(t,e){const r=this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(t.getX()),Math.floor(t.getY()),Math.floor(e.getX()),Math.floor(e.getY())),n=this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(e.getX()),Math.floor(e.getY()),Math.floor(t.getX()),Math.floor(t.getY()));return isNaN(r)?n/7:isNaN(n)?r/7:(r+n)/14}sizeOfBlackWhiteBlackRunBothWays(t,e,r,n){let i=this.sizeOfBlackWhiteBlackRun(t,e,r,n),s=1,o=t-(r-t);o<0?(s=t/(t-o),o=0):o>=this.image.getWidth()&&(s=(this.image.getWidth()-1-t)/(o-t),o=this.image.getWidth()-1);let a=Math.floor(e-(n-e)*s);return s=1,a<0?(s=e/(e-a),a=0):a>=this.image.getHeight()&&(s=(this.image.getHeight()-1-e)/(a-e),a=this.image.getHeight()-1),o=Math.floor(t+(o-t)*s),i+=this.sizeOfBlackWhiteBlackRun(t,e,o,a),i-1}sizeOfBlackWhiteBlackRun(t,e,r,n){const i=Math.abs(n-e)>Math.abs(r-t);if(i){let i=t;t=e,e=i,i=r,r=n,n=i}const s=Math.abs(r-t),o=Math.abs(n-e);let a=-s/2;const h=t<r?1:-1,l=e<n?1:-1;let c=0;const d=r+h;for(let r=t,u=e;r!==d;r+=h){const h=i?u:r,d=i?r:u;if(1===c===this.image.get(h,d)){if(2===c)return dt.distance(r,u,t,e);c++}if(a+=o,a>0){if(u===n)break;u+=l,a-=s}}return 2===c?dt.distance(r+h,n,t,e):NaN}findAlignmentInRegion(t,e,r,n){const i=Math.floor(n*t),s=Math.max(0,e-i),o=Math.min(this.image.getWidth()-1,e+i);if(o-s<3*t)throw new O("Alignment top exceeds estimated module size.");const a=Math.max(0,r-i),h=Math.min(this.image.getHeight()-1,r+i);if(h-a<3*t)throw new O("Alignment bottom exceeds estimated module size.");return new pt(this.image,s,a,o-s,h-a,t,this.resultPointCallback).find()}}class yt{constructor(){this.decoder=new ct}getDecoder(){return this.decoder}decode(t,e){let r,n;if(null!=e&&void 0!==e.get(A.PURE_BARCODE)){const i=yt.extractPureBits(t.getBlackMatrix());r=this.decoder.decodeBitMatrix(i,e),n=yt.NO_POINTS}else{const i=new _t(t.getBlackMatrix()).detect(e);r=this.decoder.decodeBitMatrix(i.getBits(),e),n=i.getPoints()}r.getOther()instanceof lt&&r.getOther().applyMirroredCorrection(n);const i=new U(r.getText(),r.getRawBytes(),void 0,n,L.QR_CODE,void 0),s=r.getByteSegments();null!==s&&i.putMetadata(K.BYTE_SEGMENTS,s);const o=r.getECLevel();return null!==o&&i.putMetadata(K.ERROR_CORRECTION_LEVEL,o),r.hasStructuredAppend()&&(i.putMetadata(K.STRUCTURED_APPEND_SEQUENCE,r.getStructuredAppendSequenceNumber()),i.putMetadata(K.STRUCTURED_APPEND_PARITY,r.getStructuredAppendParity())),i}reset(){}static extractPureBits(t){const e=t.getTopLeftOnBit(),r=t.getBottomRightOnBit();if(null===e||null===r)throw new O;const n=this.moduleSize(e,t);let i=e[1],s=r[1],o=e[0],a=r[0];if(o>=a||i>=s)throw new O;if(s-i!=a-o&&(a=o+(s-i),a>=t.getWidth()))throw new O;const h=Math.round((a-o+1)/n),l=Math.round((s-i+1)/n);if(h<=0||l<=0)throw new O;if(l!==h)throw new O;const c=Math.floor(n/2);i+=c,o+=c;const d=o+Math.floor((h-1)*n)-a;if(d>0){if(d>c)throw new O;o-=d}const u=i+Math.floor((l-1)*n)-s;if(u>0){if(u>c)throw new O;i-=u}const f=new M(h,l);for(let e=0;e<l;e++){const r=i+Math.floor(e*n);for(let i=0;i<h;i++)t.get(o+Math.floor(i*n),r)&&f.set(i,e)}return f}static moduleSize(t,e){const r=e.getHeight(),n=e.getWidth();let i=t[0],s=t[1],o=!0,a=0;for(;i<n&&s<r;){if(o!==e.get(i,s)){if(5==++a)break;o=!o}i++,s++}if(i===n||s===r)throw new O;return(i-t[0])/7}}yt.NO_POINTS=new Array;!function(t){t[t.ERROR_CORRECTION=0]="ERROR_CORRECTION",t[t.CHARACTER_SET=1]="CHARACTER_SET",t[t.DATA_MATRIX_SHAPE=2]="DATA_MATRIX_SHAPE",t[t.DATA_MATRIX_COMPACT=3]="DATA_MATRIX_COMPACT",t[t.MIN_SIZE=4]="MIN_SIZE",t[t.MAX_SIZE=5]="MAX_SIZE",t[t.MARGIN=6]="MARGIN",t[t.PDF417_COMPACT=7]="PDF417_COMPACT",t[t.PDF417_COMPACTION=8]="PDF417_COMPACTION",t[t.PDF417_DIMENSIONS=9]="PDF417_DIMENSIONS",t[t.AZTEC_LAYERS=10]="AZTEC_LAYERS",t[t.QR_VERSION=11]="QR_VERSION",t[t.GS1_FORMAT=12]="GS1_FORMAT",t[t.FORCE_C40=13]="FORCE_C40"}(H||(H={}));var Mt=H;class Ot{constructor(t){this.field=t,this.cachedGenerators=[],this.cachedGenerators.push(new G(t,Int32Array.from([1])))}buildGenerator(t){const e=this.cachedGenerators;if(t>=e.length){let r=e[e.length-1];const n=this.field;for(let i=e.length;i<=t;i++){const t=r.multiply(new G(n,Int32Array.from([1,n.exp(i-1+n.getGeneratorBase())])));e.push(t),r=t}}return e[t]}encode(t,e){if(0===e)throw new a("No error correction bytes");const r=t.length-e;if(r<=0)throw new a("No data bytes provided");const n=this.buildGenerator(e),i=new Int32Array(r);d.arraycopy(t,0,i,0,r);let s=new G(this.field,i);s=s.multiplyByMonomial(e,1);const o=s.divide(n)[1].getCoefficients(),h=e-o.length;for(let e=0;e<h;e++)t[r+e]=0;d.arraycopy(o,0,t,r+h,o.length)}}class Nt{constructor(){}static applyMaskPenaltyRule1(t){return Nt.applyMaskPenaltyRule1Internal(t,!0)+Nt.applyMaskPenaltyRule1Internal(t,!1)}static applyMaskPenaltyRule2(t){let e=0;const r=t.getArray(),n=t.getWidth(),i=t.getHeight();for(let t=0;t<i-1;t++){const i=r[t];for(let s=0;s<n-1;s++){const n=i[s];n===i[s+1]&&n===r[t+1][s]&&n===r[t+1][s+1]&&e++}}return Nt.N2*e}static applyMaskPenaltyRule3(t){let e=0;const r=t.getArray(),n=t.getWidth(),i=t.getHeight();for(let t=0;t<i;t++)for(let s=0;s<n;s++){const o=r[t];s+6<n&&1===o[s]&&0===o[s+1]&&1===o[s+2]&&1===o[s+3]&&1===o[s+4]&&0===o[s+5]&&1===o[s+6]&&(Nt.isWhiteHorizontal(o,s-4,s)||Nt.isWhiteHorizontal(o,s+7,s+11))&&e++,t+6<i&&1===r[t][s]&&0===r[t+1][s]&&1===r[t+2][s]&&1===r[t+3][s]&&1===r[t+4][s]&&0===r[t+5][s]&&1===r[t+6][s]&&(Nt.isWhiteVertical(r,s,t-4,t)||Nt.isWhiteVertical(r,s,t+7,t+11))&&e++}return e*Nt.N3}static isWhiteHorizontal(t,e,r){e=Math.max(e,0),r=Math.min(r,t.length);for(let n=e;n<r;n++)if(1===t[n])return!1;return!0}static isWhiteVertical(t,e,r,n){r=Math.max(r,0),n=Math.min(n,t.length);for(let i=r;i<n;i++)if(1===t[i][e])return!1;return!0}static applyMaskPenaltyRule4(t){let e=0;const r=t.getArray(),n=t.getWidth(),i=t.getHeight();for(let t=0;t<i;t++){const i=r[t];for(let t=0;t<n;t++)1===i[t]&&e++}const s=t.getHeight()*t.getWidth();return Math.floor(10*Math.abs(2*e-s)/s)*Nt.N4}static getDataMaskBit(t,e,r){let n,i;switch(t){case 0:n=r+e&1;break;case 1:n=1&r;break;case 2:n=e%3;break;case 3:n=(r+e)%3;break;case 4:n=Math.floor(r/2)+Math.floor(e/3)&1;break;case 5:i=r*e,n=(1&i)+i%3;break;case 6:i=r*e,n=(1&i)+i%3&1;break;case 7:i=r*e,n=i%3+(r+e&1)&1;break;default:throw new a("Invalid mask pattern: "+t)}return 0===n}static applyMaskPenaltyRule1Internal(t,e){let r=0;const n=e?t.getHeight():t.getWidth(),i=e?t.getWidth():t.getHeight(),s=t.getArray();for(let t=0;t<n;t++){let n=0,o=-1;for(let a=0;a<i;a++){const i=e?s[t][a]:s[a][t];i===o?n++:(n>=5&&(r+=Nt.N1+(n-5)),n=1,o=i)}n>=5&&(r+=Nt.N1+(n-5))}return r}}Nt.N1=3,Nt.N2=3,Nt.N3=40,Nt.N4=10;class bt{constructor(t,e){this.width=t,this.height=e;const r=new Array(e);for(let n=0;n!==e;n++)r[n]=new Uint8Array(t);this.bytes=r}getHeight(){return this.height}getWidth(){return this.width}get(t,e){return this.bytes[e][t]}getArray(){return this.bytes}setNumber(t,e,r){this.bytes[e][t]=r}setBoolean(t,e,r){this.bytes[e][t]=r?1:0}clear(t){for(const e of this.bytes)w.fill(e,t)}equals(t){if(!(t instanceof bt))return!1;const e=t;if(this.width!==e.width)return!1;if(this.height!==e.height)return!1;for(let t=0,r=this.height;t<r;++t){const r=this.bytes[t],n=e.bytes[t];for(let t=0,e=this.width;t<e;++t)if(r[t]!==n[t])return!1}return!0}toString(){const t=new y;for(let e=0,r=this.height;e<r;++e){const r=this.bytes[e];for(let e=0,n=this.width;e<n;++e)switch(r[e]){case 0:t.append(" 0");break;case 1:t.append(" 1");break;default:t.append("  ")}t.append("\n")}return t.toString()}}class Tt{constructor(){this.maskPattern=-1}getMode(){return this.mode}getECLevel(){return this.ecLevel}getVersion(){return this.version}getMaskPattern(){return this.maskPattern}getMatrix(){return this.matrix}toString(){const t=new y;return t.append("<<\n"),t.append(" mode: "),t.append(this.mode?this.mode.toString():"null"),t.append("\n ecLevel: "),t.append(this.ecLevel?this.ecLevel.toString():"null"),t.append("\n version: "),t.append(this.version?this.version.toString():"null"),t.append("\n maskPattern: "),t.append(this.maskPattern.toString()),this.matrix?(t.append("\n matrix:\n"),t.append(this.matrix.toString())):t.append("\n matrix: null\n"),t.append(">>\n"),t.toString()}setMode(t){this.mode=t}setECLevel(t){this.ecLevel=t}setVersion(t){this.version=t}setMaskPattern(t){this.maskPattern=t}setMatrix(t){this.matrix=t}static isValidMaskPattern(t){return t>=0&&t<Tt.NUM_MASK_PATTERNS}}Tt.NUM_MASK_PATTERNS=8;class Bt extends s{}Bt.kind="WriterException";class Rt{constructor(){}static clearMatrix(t){t.clear(255)}static buildMatrix(t,e,r,n,i){Rt.clearMatrix(i),Rt.embedBasicPatterns(r,i),Rt.embedTypeInfo(e,n,i),Rt.maybeEmbedVersionInfo(r,i),Rt.embedDataBits(t,n,i)}static embedBasicPatterns(t,e){Rt.embedPositionDetectionPatternsAndSeparators(e),Rt.embedDarkDotAtLeftBottomCorner(e),Rt.maybeEmbedPositionAdjustmentPatterns(t,e),Rt.embedTimingPatterns(e)}static embedTypeInfo(t,e,r){const n=new m;Rt.makeTypeInfoBits(t,e,n);for(let t=0,e=n.getSize();t<e;++t){const e=n.get(n.getSize()-1-t),i=Rt.TYPE_INFO_COORDINATES[t],s=i[0],o=i[1];if(r.setBoolean(s,o,e),t<8){const n=r.getWidth()-t-1,i=8;r.setBoolean(n,i,e)}else{const n=8,i=r.getHeight()-7+(t-8);r.setBoolean(n,i,e)}}}static maybeEmbedVersionInfo(t,e){if(t.getVersionNumber()<7)return;const r=new m;Rt.makeVersionInfoBits(t,r);let n=17;for(let t=0;t<6;++t)for(let i=0;i<3;++i){const s=r.get(n);n--,e.setBoolean(t,e.getHeight()-11+i,s),e.setBoolean(e.getHeight()-11+i,t,s)}}static embedDataBits(t,e,r){let n=0,i=-1,s=r.getWidth()-1,o=r.getHeight()-1;for(;s>0;){for(6===s&&(s-=1);o>=0&&o<r.getHeight();){for(let i=0;i<2;++i){const a=s-i;if(!Rt.isEmpty(r.get(a,o)))continue;let h;n<t.getSize()?(h=t.get(n),++n):h=!1,255!==e&&Nt.getDataMaskBit(e,a,o)&&(h=!h),r.setBoolean(a,o,h)}o+=i}i=-i,o+=i,s-=2}if(n!==t.getSize())throw new Bt("Not all bits consumed: "+n+"/"+t.getSize())}static findMSBSet(t){return 32-g.numberOfLeadingZeros(t)}static calculateBCHCode(t,e){if(0===e)throw new a("0 polynomial");const r=Rt.findMSBSet(e);for(t<<=r-1;Rt.findMSBSet(t)>=r;)t^=e<<Rt.findMSBSet(t)-r;return t}static makeTypeInfoBits(t,e,r){if(!Tt.isValidMaskPattern(e))throw new Bt("Invalid mask pattern");const n=t.getBits()<<3|e;r.appendBits(n,5);const i=Rt.calculateBCHCode(n,Rt.TYPE_INFO_POLY);r.appendBits(i,10);const s=new m;if(s.appendBits(Rt.TYPE_INFO_MASK_PATTERN,15),r.xor(s),15!==r.getSize())throw new Bt("should not happen but we got: "+r.getSize())}static makeVersionInfoBits(t,e){e.appendBits(t.getVersionNumber(),6);const r=Rt.calculateBCHCode(t.getVersionNumber(),Rt.VERSION_INFO_POLY);if(e.appendBits(r,12),18!==e.getSize())throw new Bt("should not happen but we got: "+e.getSize())}static isEmpty(t){return 255===t}static embedTimingPatterns(t){for(let e=8;e<t.getWidth()-8;++e){const r=(e+1)%2;Rt.isEmpty(t.get(e,6))&&t.setNumber(e,6,r),Rt.isEmpty(t.get(6,e))&&t.setNumber(6,e,r)}}static embedDarkDotAtLeftBottomCorner(t){if(0===t.get(8,t.getHeight()-8))throw new Bt;t.setNumber(8,t.getHeight()-8,1)}static embedHorizontalSeparationPattern(t,e,r){for(let n=0;n<8;++n){if(!Rt.isEmpty(r.get(t+n,e)))throw new Bt;r.setNumber(t+n,e,0)}}static embedVerticalSeparationPattern(t,e,r){for(let n=0;n<7;++n){if(!Rt.isEmpty(r.get(t,e+n)))throw new Bt;r.setNumber(t,e+n,0)}}static embedPositionAdjustmentPattern(t,e,r){for(let n=0;n<5;++n){const i=Rt.POSITION_ADJUSTMENT_PATTERN[n];for(let s=0;s<5;++s)r.setNumber(t+s,e+n,i[s])}}static embedPositionDetectionPattern(t,e,r){for(let n=0;n<7;++n){const i=Rt.POSITION_DETECTION_PATTERN[n];for(let s=0;s<7;++s)r.setNumber(t+s,e+n,i[s])}}static embedPositionDetectionPatternsAndSeparators(t){const e=Rt.POSITION_DETECTION_PATTERN[0].length;Rt.embedPositionDetectionPattern(0,0,t),Rt.embedPositionDetectionPattern(t.getWidth()-e,0,t),Rt.embedPositionDetectionPattern(0,t.getWidth()-e,t);Rt.embedHorizontalSeparationPattern(0,7,t),Rt.embedHorizontalSeparationPattern(t.getWidth()-8,7,t),Rt.embedHorizontalSeparationPattern(0,t.getWidth()-8,t);Rt.embedVerticalSeparationPattern(7,0,t),Rt.embedVerticalSeparationPattern(t.getHeight()-7-1,0,t),Rt.embedVerticalSeparationPattern(7,t.getHeight()-7,t)}static maybeEmbedPositionAdjustmentPatterns(t,e){if(t.getVersionNumber()<2)return;const r=t.getVersionNumber()-1,n=Rt.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[r];for(let t=0,r=n.length;t!==r;t++){const i=n[t];if(i>=0)for(let t=0;t!==r;t++){const r=n[t];r>=0&&Rt.isEmpty(e.get(r,i))&&Rt.embedPositionAdjustmentPattern(r-2,i-2,e)}}}}Rt.POSITION_DETECTION_PATTERN=Array.from([Int32Array.from([1,1,1,1,1,1,1]),Int32Array.from([1,0,0,0,0,0,1]),Int32Array.from([1,0,1,1,1,0,1]),Int32Array.from([1,0,1,1,1,0,1]),Int32Array.from([1,0,1,1,1,0,1]),Int32Array.from([1,0,0,0,0,0,1]),Int32Array.from([1,1,1,1,1,1,1])]),Rt.POSITION_ADJUSTMENT_PATTERN=Array.from([Int32Array.from([1,1,1,1,1]),Int32Array.from([1,0,0,0,1]),Int32Array.from([1,0,1,0,1]),Int32Array.from([1,0,0,0,1]),Int32Array.from([1,1,1,1,1])]),Rt.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE=Array.from([Int32Array.from([-1,-1,-1,-1,-1,-1,-1]),Int32Array.from([6,18,-1,-1,-1,-1,-1]),Int32Array.from([6,22,-1,-1,-1,-1,-1]),Int32Array.from([6,26,-1,-1,-1,-1,-1]),Int32Array.from([6,30,-1,-1,-1,-1,-1]),Int32Array.from([6,34,-1,-1,-1,-1,-1]),Int32Array.from([6,22,38,-1,-1,-1,-1]),Int32Array.from([6,24,42,-1,-1,-1,-1]),Int32Array.from([6,26,46,-1,-1,-1,-1]),Int32Array.from([6,28,50,-1,-1,-1,-1]),Int32Array.from([6,30,54,-1,-1,-1,-1]),Int32Array.from([6,32,58,-1,-1,-1,-1]),Int32Array.from([6,34,62,-1,-1,-1,-1]),Int32Array.from([6,26,46,66,-1,-1,-1]),Int32Array.from([6,26,48,70,-1,-1,-1]),Int32Array.from([6,26,50,74,-1,-1,-1]),Int32Array.from([6,30,54,78,-1,-1,-1]),Int32Array.from([6,30,56,82,-1,-1,-1]),Int32Array.from([6,30,58,86,-1,-1,-1]),Int32Array.from([6,34,62,90,-1,-1,-1]),Int32Array.from([6,28,50,72,94,-1,-1]),Int32Array.from([6,26,50,74,98,-1,-1]),Int32Array.from([6,30,54,78,102,-1,-1]),Int32Array.from([6,28,54,80,106,-1,-1]),Int32Array.from([6,32,58,84,110,-1,-1]),Int32Array.from([6,30,58,86,114,-1,-1]),Int32Array.from([6,34,62,90,118,-1,-1]),Int32Array.from([6,26,50,74,98,122,-1]),Int32Array.from([6,30,54,78,102,126,-1]),Int32Array.from([6,26,52,78,104,130,-1]),Int32Array.from([6,30,56,82,108,134,-1]),Int32Array.from([6,34,60,86,112,138,-1]),Int32Array.from([6,30,58,86,114,142,-1]),Int32Array.from([6,34,62,90,118,146,-1]),Int32Array.from([6,30,54,78,102,126,150]),Int32Array.from([6,24,50,76,102,128,154]),Int32Array.from([6,28,54,80,106,132,158]),Int32Array.from([6,32,58,84,110,136,162]),Int32Array.from([6,26,54,82,110,138,166]),Int32Array.from([6,30,58,86,114,142,170])]),Rt.TYPE_INFO_COORDINATES=Array.from([Int32Array.from([8,0]),Int32Array.from([8,1]),Int32Array.from([8,2]),Int32Array.from([8,3]),Int32Array.from([8,4]),Int32Array.from([8,5]),Int32Array.from([8,7]),Int32Array.from([8,8]),Int32Array.from([7,8]),Int32Array.from([5,8]),Int32Array.from([4,8]),Int32Array.from([3,8]),Int32Array.from([2,8]),Int32Array.from([1,8]),Int32Array.from([0,8])]),Rt.VERSION_INFO_POLY=7973,Rt.TYPE_INFO_POLY=1335,Rt.TYPE_INFO_MASK_PATTERN=21522;class vt{constructor(t,e){this.dataBytes=t,this.errorCorrectionBytes=e}getDataBytes(){return this.dataBytes}getErrorCorrectionBytes(){return this.errorCorrectionBytes}}class Dt{constructor(){}static calculateMaskPenalty(t){return Nt.applyMaskPenaltyRule1(t)+Nt.applyMaskPenaltyRule2(t)+Nt.applyMaskPenaltyRule3(t)+Nt.applyMaskPenaltyRule4(t)}static encode(t,e,r=null){let n=Dt.DEFAULT_BYTE_MODE_ENCODING;const i=null!==r&&void 0!==r.get(Mt.CHARACTER_SET);i&&(n=r.get(Mt.CHARACTER_SET).toString());const s=this.chooseMode(t,n),o=new m;if(s===at.BYTE&&(i||Dt.DEFAULT_BYTE_MODE_ENCODING!==n)){const t=E.getCharacterSetECIByName(n);void 0!==t&&this.appendECI(t,o)}this.appendModeInfo(s,o);const a=new m;let h;if(this.appendBytes(t,s,a,n),null!==r&&void 0!==r.get(Mt.QR_VERSION)){const t=Number.parseInt(r.get(Mt.QR_VERSION).toString(),10);h=et.getVersionForNumber(t);const n=this.calculateBitsNeeded(s,o,a,h);if(!this.willFit(n,h,e))throw new Bt("Data too big for requested version")}else h=this.recommendVersion(e,s,o,a);const l=new m;l.appendBitArray(o);const c=s===at.BYTE?a.getSizeInBytes():t.length;this.appendLengthInfo(c,h,s,l),l.appendBitArray(a);const d=h.getECBlocksForLevel(e),u=h.getTotalCodewords()-d.getTotalECCodewords();this.terminateBits(u,l);const f=this.interleaveWithECBytes(l,h.getTotalCodewords(),u,d.getNumBlocks()),w=new Tt;w.setECLevel(e),w.setMode(s),w.setVersion(h);const g=h.getDimensionForVersion(),I=new bt(g,g),A=this.chooseMaskPattern(f,e,h,I);return w.setMaskPattern(A),Rt.buildMatrix(f,e,h,A,I),w.setMatrix(I),w}static recommendVersion(t,e,r,n){const i=this.calculateBitsNeeded(e,r,n,et.getVersionForNumber(1)),s=this.chooseVersion(i,t),o=this.calculateBitsNeeded(e,r,n,s);return this.chooseVersion(o,t)}static calculateBitsNeeded(t,e,r,n){return e.getSize()+t.getCharacterCountBits(n)+r.getSize()}static getAlphanumericCode(t){return t<Dt.ALPHANUMERIC_TABLE.length?Dt.ALPHANUMERIC_TABLE[t]:-1}static chooseMode(t,e=null){if(E.SJIS.getName()===e&&this.isOnlyDoubleByteKanji(t))return at.KANJI;let r=!1,n=!1;for(let e=0,i=t.length;e<i;++e){const i=t.charAt(e);if(Dt.isDigit(i))r=!0;else{if(-1===this.getAlphanumericCode(i.charCodeAt(0)))return at.BYTE;n=!0}}return n?at.ALPHANUMERIC:r?at.NUMERIC:at.BYTE}static isOnlyDoubleByteKanji(t){let e;try{e=C.encode(t,E.SJIS)}catch(t){return!1}const r=e.length;if(r%2!=0)return!1;for(let t=0;t<r;t+=2){const r=255&e[t];if((r<129||r>159)&&(r<224||r>235))return!1}return!0}static chooseMaskPattern(t,e,r,n){let i=Number.MAX_SAFE_INTEGER,s=-1;for(let o=0;o<Tt.NUM_MASK_PATTERNS;o++){Rt.buildMatrix(t,e,r,o,n);let a=this.calculateMaskPenalty(n);a<i&&(i=a,s=o)}return s}static chooseVersion(t,e){for(let r=1;r<=40;r++){const n=et.getVersionForNumber(r);if(Dt.willFit(t,n,e))return n}throw new Bt("Data too big")}static willFit(t,e,r){return e.getTotalCodewords()-e.getECBlocksForLevel(r).getTotalECCodewords()>=(t+7)/8}static terminateBits(t,e){const r=8*t;if(e.getSize()>r)throw new Bt("data bits cannot fit in the QR Code"+e.getSize()+" > "+r);for(let t=0;t<4&&e.getSize()<r;++t)e.appendBit(!1);const n=7&e.getSize();if(n>0)for(let t=n;t<8;t++)e.appendBit(!1);const i=t-e.getSizeInBytes();for(let t=0;t<i;++t)e.appendBits(1&t?17:236,8);if(e.getSize()!==r)throw new Bt("Bits size does not equal capacity")}static getNumDataBytesAndNumECBytesForBlockID(t,e,r,n,i,s){if(n>=r)throw new Bt("Block ID too large");const o=t%r,a=r-o,h=Math.floor(t/r),l=h+1,c=Math.floor(e/r),d=c+1,u=h-c,f=l-d;if(u!==f)throw new Bt("EC bytes mismatch");if(r!==a+o)throw new Bt("RS blocks mismatch");if(t!==(c+u)*a+(d+f)*o)throw new Bt("Total bytes mismatch");n<a?(i[0]=c,s[0]=u):(i[0]=d,s[0]=f)}static interleaveWithECBytes(t,e,r,n){if(t.getSizeInBytes()!==r)throw new Bt("Number of bits and data bytes does not match");let i=0,s=0,o=0;const a=new Array;for(let h=0;h<n;++h){const l=new Int32Array(1),c=new Int32Array(1);Dt.getNumDataBytesAndNumECBytesForBlockID(e,r,n,h,l,c);const d=l[0],u=new Uint8Array(d);t.toBytes(8*i,u,0,d);const f=Dt.generateECBytes(u,c[0]);a.push(new vt(u,f)),s=Math.max(s,d),o=Math.max(o,f.length),i+=l[0]}if(r!==i)throw new Bt("Data bytes does not match offset");const h=new m;for(let t=0;t<s;++t)for(const e of a){const r=e.getDataBytes();t<r.length&&h.appendBits(r[t],8)}for(let t=0;t<o;++t)for(const e of a){const r=e.getErrorCorrectionBytes();t<r.length&&h.appendBits(r[t],8)}if(e!==h.getSizeInBytes())throw new Bt("Interleaving error: "+e+" and "+h.getSizeInBytes()+" differ.");return h}static generateECBytes(t,e){const r=t.length,n=new Int32Array(r+e);for(let e=0;e<r;e++)n[e]=255&t[e];new Ot(X.QR_CODE_FIELD_256).encode(n,e);const i=new Uint8Array(e);for(let t=0;t<e;t++)i[t]=n[r+t];return i}static appendModeInfo(t,e){e.appendBits(t.getBits(),4)}static appendLengthInfo(t,e,r,n){const i=r.getCharacterCountBits(e);if(t>=1<<i)throw new Bt(t+" is bigger than "+((1<<i)-1));n.appendBits(t,i)}static appendBytes(t,e,r,n){switch(e){case at.NUMERIC:Dt.appendNumericBytes(t,r);break;case at.ALPHANUMERIC:Dt.appendAlphanumericBytes(t,r);break;case at.BYTE:Dt.append8BitBytes(t,r,n);break;case at.KANJI:Dt.appendKanjiBytes(t,r);break;default:throw new Bt("Invalid mode: "+e)}}static getDigit(t){return t.charCodeAt(0)-48}static isDigit(t){const e=Dt.getDigit(t);return e>=0&&e<=9}static appendNumericBytes(t,e){const r=t.length;let n=0;for(;n<r;){const i=Dt.getDigit(t.charAt(n));if(n+2<r){const r=Dt.getDigit(t.charAt(n+1)),s=Dt.getDigit(t.charAt(n+2));e.appendBits(100*i+10*r+s,10),n+=3}else if(n+1<r){const r=Dt.getDigit(t.charAt(n+1));e.appendBits(10*i+r,7),n+=2}else e.appendBits(i,4),n++}}static appendAlphanumericBytes(t,e){const r=t.length;let n=0;for(;n<r;){const i=Dt.getAlphanumericCode(t.charCodeAt(n));if(-1===i)throw new Bt;if(n+1<r){const r=Dt.getAlphanumericCode(t.charCodeAt(n+1));if(-1===r)throw new Bt;e.appendBits(45*i+r,11),n+=2}else e.appendBits(i,6),n++}}static append8BitBytes(t,e,r){let n;try{n=C.encode(t,r)}catch(t){throw new Bt(t)}for(let t=0,r=n.length;t!==r;t++){const r=n[t];e.appendBits(r,8)}}static appendKanjiBytes(t,e){let r;try{r=C.encode(t,E.SJIS)}catch(t){throw new Bt(t)}const n=r.length;for(let t=0;t<n;t+=2){const n=(255&r[t])<<8&4294967295|255&r[t+1];let i=-1;if(n>=33088&&n<=40956?i=n-33088:n>=57408&&n<=60351&&(i=n-49472),-1===i)throw new Bt("Invalid byte sequence");const s=192*(i>>8)+(255&i);e.appendBits(s,13)}}static appendECI(t,e){e.appendBits(at.ECI.getBits(),4),e.appendBits(t.getValue(),8)}}Dt.ALPHANUMERIC_TABLE=Int32Array.from([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,36,-1,-1,-1,37,38,-1,-1,-1,-1,39,40,-1,41,42,43,0,1,2,3,4,5,6,7,8,9,44,-1,-1,-1,-1,-1,-1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1]),Dt.DEFAULT_BYTE_MODE_ENCODING=E.UTF8.getName();class Pt{write(t,e,r,n=null){if(0===t.length)throw new a("Found empty contents");if(e<0||r<0)throw new a("Requested dimensions are too small: "+e+"x"+r);let i=J.L,s=Pt.QUIET_ZONE_SIZE;null!==n&&(void 0!==n.get(Mt.ERROR_CORRECTION)&&(i=J.fromString(n.get(Mt.ERROR_CORRECTION).toString())),void 0!==n.get(Mt.MARGIN)&&(s=Number.parseInt(n.get(Mt.MARGIN).toString(),10)));const o=Dt.encode(t,i,n);return this.renderResult(o,e,r,s)}writeToDom(t,e,r,n,i=null){"string"==typeof t&&(t=document.querySelector(t));const s=this.write(e,r,n,i);t&&t.appendChild(s)}renderResult(t,e,r,n){const i=t.getMatrix();if(null===i)throw new Q;const s=i.getWidth(),o=i.getHeight(),a=s+2*n,h=o+2*n,l=Math.max(e,a),c=Math.max(r,h),d=Math.min(Math.floor(l/a),Math.floor(c/h)),u=Math.floor((l-s*d)/2),f=Math.floor((c-o*d)/2),w=this.createSVGElement(l,c);for(let t=0,e=f;t<o;t++,e+=d)for(let r=0,n=u;r<s;r++,n+=d)if(1===i.get(r,t)){const t=this.createSvgRectElement(n,e,d,d);w.appendChild(t)}return w}createSVGElement(t,e){const r=document.createElementNS(Pt.SVG_NS,"svg");return r.setAttributeNS(null,"height",t.toString()),r.setAttributeNS(null,"width",e.toString()),r}createSvgRectElement(t,e,r,n){const i=document.createElementNS(Pt.SVG_NS,"rect");return i.setAttributeNS(null,"x",t.toString()),i.setAttributeNS(null,"y",e.toString()),i.setAttributeNS(null,"height",r.toString()),i.setAttributeNS(null,"width",n.toString()),i.setAttributeNS(null,"fill","#000000"),i}}Pt.QUIET_ZONE_SIZE=4,Pt.SVG_NS="http://www.w3.org/2000/svg";class Ft extends s{}Ft.kind="ReaderException";class kt{}kt.ISO_8859_1=E.ISO8859_1;class Lt{encode(t,e,r,n,i){if(0===t.length)throw new a("Found empty contents");if(e!==L.QR_CODE)throw new a("Can only encode QR_CODE, but got "+e);if(r<0||n<0)throw new a(`Requested dimensions are too small: ${r}x${n}`);let s=J.L,o=Lt.QUIET_ZONE_SIZE;null!==i&&(void 0!==i.get(Mt.ERROR_CORRECTION)&&(s=J.fromString(i.get(Mt.ERROR_CORRECTION).toString())),void 0!==i.get(Mt.MARGIN)&&(o=Number.parseInt(i.get(Mt.MARGIN).toString(),10)));const h=Dt.encode(t,s,i);return Lt.renderResult(h,r,n,o)}static renderResult(t,e,r,n){const i=t.getMatrix();if(null===i)throw new Q;const s=i.getWidth(),o=i.getHeight(),a=s+2*n,h=o+2*n,l=Math.max(e,a),c=Math.max(r,h),d=Math.min(Math.floor(l/a),Math.floor(c/h)),u=Math.floor((l-s*d)/2),f=Math.floor((c-o*d)/2),w=new M(l,c);for(let t=0,e=f;t<o;t++,e+=d)for(let r=0,n=u;r<s;r++,n+=d)1===i.get(r,t)&&w.setRegion(n,e,d,d);return w}}Lt.QUIET_ZONE_SIZE=4,t.ArgumentException=o,t.ArithmeticException=Z,t.BrowserCodeReader=F,t.BrowserQRCodeReader=class extends F{constructor(t=500){super(new yt,t)}},t.BrowserQRCodeSvgWriter=Pt,t.ChecksumException=l,t.DecodeHintType=A,t.DecoderResult=ot,t.EncodeHintType=Mt,t.Exception=s,t.FormatException=p,t.GenericGF=X,t.GenericGFPoly=G,t.HTMLCanvasElementLuminanceSource=R,t.IllegalArgumentException=a,t.IllegalStateException=Q,t.MathUtils=dt,t.NotFoundException=O,t.QRCodeByteMatrix=bt,t.QRCodeDataMask=rt,t.QRCodeDecodedBitStreamParser=ht,t.QRCodeDecoderErrorCorrectionLevel=J,t.QRCodeDecoderFormatInformation=j,t.QRCodeEncoder=Dt,t.QRCodeEncoderQRCode=Tt,t.QRCodeMaskUtil=Nt,t.QRCodeMatrixUtil=Rt,t.QRCodeMode=at,t.QRCodeReader=yt,t.QRCodeVersion=et,t.QRCodeWriter=Lt,t.ReaderException=Ft,t.ReedSolomonDecoder=q,t.ReedSolomonEncoder=Ot,t.ReedSolomonException=Y,t.Result=U,t.UnsupportedOperationException=S,t.VideoInputDevice=v,t.WriterException=Bt,t.ZXingArrays=w,t.ZXingCharset=class extends E{static forName(t){return this.getCharacterSetECIByName(t)}},t.ZXingInteger=g,t.ZXingStandardCharsets=kt,t.ZXingStringBuilder=y,t.ZXingStringEncoding=C,t.ZXingSystem=d,Object.defineProperty(t,"__esModule",{value:!0})}));
</script><script>Ve.ContentLoad(async () => {
  const { HTML } = Ve;

  Ve.ById.loading.style.display = 'none';
  Ve.ById.compose.placeholder = '/upload';

  compose.on.keyup(async ev => {
    if (ev.key === 'Enter') {
      const value = compose.value.replaceAll('\u2588', '').trim();
      if (/\w+/.exec(value)[0] === 'upload') {
        compose.value = "";
        Ve.ById.file_upload.click();
      }
    }
  });
  const onQR = async result => {
    console.log(result);
    if (result.text.startsWith("data:")) {
      const onclick = async event => {
        if (navigator?.clipboard?.writeText) {
          event.preventDefault();
          await navigator.clipboard.writeText(result.text);
          alert('Copied data URI! You must paste it into your browser URL manually');
        }
      };
      host_ui.logEvent(HTML.a({href:result.text,onclick}, result.text));
    } else if (result.text.startsWith("http://") || result.text.startsWith("https://")) {
      host_ui.logEvent(HTML.a({href:result.text}, result.text));
    } else {
      host_ui.logEvent(result.text);
    }
  };
  host_ui.uploadQR(onQR);
  const scanner = await host_ui.scanQR(onQR);
  Ve.ById.chat_content.appendChild(scanner);
});
</script></head><body><div id="main">
  <h1 id="title" style="font-size: 2rem">
    <svg id="favicon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="#eee">
      <path d="M44.8 22.4a22.4 22.4 0 0 1-44.8 0V0h22.4a22.4 22.4 0 0 1 22.4 22.4Z" fill="#1d2443" />
      <path d="M64 41.6a22.4 22.4 0 1 1-22.4-22.4H64v22.4z" fill="#4f3362" />
      <path
        d="M16.11 13.42c0-.92.58-1.4 2.88-1.4 2.2 0 4.55.6 4.55 4.41 0 3.68-1.8 4.87-4.9 4.87-.8 0-2.11-.1-2.53-.32zm-2.75 3.84v7.84c0 2.4-.06 4.68-.32 6.4l.06.1a13.96 13.96 0 0 1 3.27 0l.06-.1c-.25-1.82-.32-4-.32-6.4v-2.75c.7.23 1.57.32 2.69.32 5.82 0 7.84-3.68 7.84-6.4 0-2.37-1.5-5.63-7.42-5.63-.84 0-3.52.22-4.48.22-.39 0-1.25-.03-1.64-.1l-.06.1c.26 1.83.32 4 .32 6.4z" aria-label="P" />
      <path
        d="M29.6 26.5c.89 0 1.87.98 1.87 2.5 0 1.56-.08 2.83-1.52 4.3l-1.81 1.78c-2.4 2.45-3.13 3.57-3.13 5.02l.02.1c2.38-.03 4.24-.1 6.1-.1 1.83 0 2.42.02 4.25.1a6.16 6.16 0 0 1 0-2.77c-1.42.1-2.1.22-4.55.22h-2c0-.4.88-1.61 1.39-2.1l2.44-2.37c1.4-1.35 2.6-2.3 2.6-4.16 0-2.64-2.55-3.84-5.46-3.84-1.76 0-3.93.8-4.55 1.34l-.07.1.52 1.93 1.07.03c.8-1.45 1.64-2.08 2.84-2.08z" aria-label="2" />
      <path
        d="M42.35 35.83c0-.93.57-1.4 2.88-1.4 2.2 0 4.54.6 4.54 4.4 0 3.69-1.8 4.87-4.9 4.87-.8 0-2.1-.1-2.52-.32zm-2.75 3.84v7.84c0 2.4-.07 4.67-.32 6.4l.06.1a13.96 13.96 0 0 1 3.26 0l.07-.1c-.26-1.82-.32-4-.32-6.4v-2.75c.7.22 1.57.32 2.69.32 5.82 0 7.84-3.68 7.84-6.4 0-2.37-1.5-5.63-7.43-5.63-.83 0-3.52.22-4.48.22-.38 0-1.25-.03-1.63-.1l-.06.1c.25 1.82.32 4 .32 6.4z" aria-label="P" />
    </svg>&thinsp;WebRTC over QR <span id="role_description"></span>
  </h1>
  <div id="chat_content">
    <div id="chat_spacer"></div>
    <div id="loading">
      <div id="introduction" style="text-align: left; line-height: 130%">
        <p>This is a project exploring how close we can get to a <em>truly</em> Peer-to-Peer WebRTC experience: just a single offline HTML file on the host, bootstrapped onto the guest via &lt;2,953 bytes of HTML squeezed into a single QR code (plus a return QR code is required for some browser engines). No servers in the middle, just two web browsers speaking WebRTC and JavaScript to each other.</p>

        <p>Please read the caveats below before trying it out! It is incredibly cool that it is even possible, and even somewhat portable between browsers (though Chromium works best), and I have done my best to smooth out the rough edges to make it pleasant to use. The concept underlying the connection procedure is relatively simple, and I have written a chat app on top to demonstrate its usefulness and test aspects like latency (try running /ping).</p>

        <p>More information and downloads at <a href="https://webrtc-over-qr.veritates.love/">https://webrtc-over-qr.veritates.love/</a>.</p>
      </div>
      <details open id="caveats">
        <summary><h2 style="display: inline; cursor: pointer">Caveats</h2></summary>

        <ul>
          <li><p>WebRTC discovery works differently across browser engines. Chromium-based browsers give the nicest experience: we are able to auto-discover guests when they open the page and try to connect. On other engines (like Safari and Firefox), the certificate fingerprint generated by the guest must be sent back to the host via some other method (QR code, copy+paste, instant message, verbal transcription, etc.).</p> <p>Our mode of connection (entirely peer-to-peer) is somewhat unintended, as WebRTC was designed to have a (trusted!) signaling server mediate a connection. Thus there is no uniform experience we can offer, although we can try our best and add workarounds for these situations.</p></li>
          <li><p>Firefox behaves very differently based on the flag <code>media.peerconnection.ice.obfuscate_host_addresses</code> in <code>about:config</code> (which is set to <code>true</code> by default). In particular, it seems to impose a ~5 second timeout as guest. And as host, it will not connect to a Chromium guest? So you might want to set this to <code>false</code> while trying the demo, or use a different browser instead. Note that it is a global setting, so remember to set it back to the default <code>true</code> when you are done.</p></li>
          <li><p>While we produce standards-compliant QR codes, they aren’t exactly usable by existing software: the QR code generated by the host contains a data URI, which most phone apps will not recognize as a link, and even if they do, browsers will not open data URIs from external sources (or in the case of Firefox on iOS, ever at all), so you may have to use a different <a href="https://webrtc-over-qr.veritates.love/scanner">QR code scanner</a> and copy and paste the URL into a browser. And on the flip side, the QR code generated by the guest is 32 bytes of raw binary data, which most scanners will not even display for you, and would not be safe to copy as text. However, this is less of an issue since we can embed a QR scanner here in secure contexts (HTTPS, localhost, and apparently local files too).</p></li>
          <li><p>A lot of nice web APIs understandably do not work in insecure contexts. The goal of bootstrapping a peer-to-peer web chat over QR is not secure, so there is not much we can do about it. This means no access to webcams or microphones, no popup notifications, etc., at least from the guest. But there is still a lot of amazing things that we can do, things that any (web) chat app could have done but didn’t.</p></li>
          <li><p>The demo has no way of reestablishing a connection if it drops (I do not know if it would be technically possible at all without manually passing information between the peers again ... you could at least pre-establish the certificates to use). The demo also does not use STUN or TURN servers, which facilitate connections behind NAT/firewalls, so it may only work between devices on your local network. <!-- This is a lie and you can add stun servers using query parameters like `?stun=stun:stun1.example.com:3478&stun=sun:stun2.example.com:3478`. --></p></li>
        </ul>
      </details>
      <hr/>
      <div id="instructions" style="text-align: left; line-height: 130%">
        <h2>Instructions</h2>

        <p>First, open the provided HTML on the guest device. You can get it as a data URI, which you will have to copy and paste into guest's browser (clicking on it will not work, and a <a href="https://webrtc-over-qr.veritates.love/scanner">QR code scanner</a> will need to give you the text of the QR code: they will not open it as a link either), or you can save the HTML to a file and load it that way, or temporarily host it on a webserver and so on.</p>

        <div id="to_guest"></div>

        <p>Then, if the connection does not automatically establish itself (if your host is not Chromium), you will need to get the certificate fingerprint from the guest. You can copy/paste it or enter it manually, or, if the host is loaded in a secure context, you can use the QR code scanner below by selecting a camera to use. Or you can take a picture of the QR code in another app and upload/paste it here.</p>

        <div id="from_guest"></div>

        <p>The WebRTC connection is not particularly time sensitive, so you should have time to open the site on the guest. However, it can only be attempted once, so if it fails or if you get the fingerprint wrong, you will need to refresh this page <!-- or call `host()` --> and restart the whole procedure again. The HTML/QR code is specific to the connection attempt, you cannot reuse it!</p>

        <p>And as mentioned in <a href="#caveats">Caveats</a>, Firefox has different behavior based on the <code>media.peerconnection.ice.obfuscate_host_addresses</code> in <code>about:config</code>. So you might want to set this to <code>false</code> while trying the demo, or try a different browser instead. Note that it is a global setting, so remember to set it back to the default <code>true</code> when you are done.</p>
      </div>
      <hr/>
      <h2>Logs</h2>
    </div>
  </div>
  <div id="controls">
    <label for="file_upload"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path style="fill:currentColor;stroke:none" d="M16 3a3 3 0 0 0-3 3v7H6a3 3 0 0 0 0 6h7v7a3 3 0 0 0 6 0v-7h7a3 3 0 0 0 0-6h-7V6a3 3 0 0 0-3-3z"/></svg></label>
    <input type="file" id="file_upload" multiple disabled />
    <input id="compose" />
  </div>
</div></body></html>