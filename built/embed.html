<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <base href="">
    <script class="stage1" src="stage1.js"></script>
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="index.css" />
    <script src="utils.js"></script>
    <script src="debug.js"></script>
    <script src="scroll.js"></script>
    <script src="verity.js"></script>
    <script src="upload.js"></script>

    <script src="app.js"></script>
    <script src="app/debug.js"></script>
    <script src="app/text.js"></script>
    <script src="app/ping.js"></script>
    <script src="app/media.js"></script>
    <script src="app/canvas.js"></script>

    <script src="media.js"></script>
    <script src="stage2.js"></script>
    <script src="host/to_guest.js"></script>
    <script src="host/from_guest.js"></script>
    <script src="host/ui.js"></script>
    <script src="host.js"></script>
    <script src="zxing.min.js"></script>
    <script class="host-only">
      window.getTemplate = async () => await (await fetch('stage0.min.html')).text();
    </script>
  </head>
  <body>
    <div id="main">
      <h1 id="title" style="font-size: 2rem">
        <svg id="favicon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="#eee">
          <path d="M44.8 22.4a22.4 22.4 0 0 1-44.8 0V0h22.4a22.4 22.4 0 0 1 22.4 22.4Z" fill="#1d2443" />
          <path d="M64 41.6a22.4 22.4 0 1 1-22.4-22.4H64v22.4z" fill="#4f3362" />
          <path
            d="M16.11 13.42c0-.92.58-1.4 2.88-1.4 2.2 0 4.55.6 4.55 4.41 0 3.68-1.8 4.87-4.9 4.87-.8 0-2.11-.1-2.53-.32zm-2.75 3.84v7.84c0 2.4-.06 4.68-.32 6.4l.06.1a13.96 13.96 0 0 1 3.27 0l.06-.1c-.25-1.82-.32-4-.32-6.4v-2.75c.7.23 1.57.32 2.69.32 5.82 0 7.84-3.68 7.84-6.4 0-2.37-1.5-5.63-7.42-5.63-.84 0-3.52.22-4.48.22-.39 0-1.25-.03-1.64-.1l-.06.1c.26 1.83.32 4 .32 6.4z" aria-label="P" />
          <path
            d="M29.6 26.5c.89 0 1.87.98 1.87 2.5 0 1.56-.08 2.83-1.52 4.3l-1.81 1.78c-2.4 2.45-3.13 3.57-3.13 5.02l.02.1c2.38-.03 4.24-.1 6.1-.1 1.83 0 2.42.02 4.25.1a6.16 6.16 0 0 1 0-2.77c-1.42.1-2.1.22-4.55.22h-2c0-.4.88-1.61 1.39-2.1l2.44-2.37c1.4-1.35 2.6-2.3 2.6-4.16 0-2.64-2.55-3.84-5.46-3.84-1.76 0-3.93.8-4.55 1.34l-.07.1.52 1.93 1.07.03c.8-1.45 1.64-2.08 2.84-2.08z" aria-label="2" />
          <path
            d="M42.35 35.83c0-.93.57-1.4 2.88-1.4 2.2 0 4.54.6 4.54 4.4 0 3.69-1.8 4.87-4.9 4.87-.8 0-2.1-.1-2.52-.32zm-2.75 3.84v7.84c0 2.4-.07 4.67-.32 6.4l.06.1a13.96 13.96 0 0 1 3.26 0l.07-.1c-.26-1.82-.32-4-.32-6.4v-2.75c.7.22 1.57.32 2.69.32 5.82 0 7.84-3.68 7.84-6.4 0-2.37-1.5-5.63-7.43-5.63-.83 0-3.52.22-4.48.22-.38 0-1.25-.03-1.63-.1l-.06.1c.25 1.82.32 4 .32 6.4z" aria-label="P" />
        </svg>&thinsp;WebRTC over QR <span id="role_description"></span>
      </h1>
      <div id="chat_content">
        <div id="chat_spacer"></div>
        <div id="loading">
          <div id="introduction" style="text-align: left; line-height: 130%">
            <p>This is a project exploring how close we can get to a <em>truly</em> Peer-to-Peer WebRTC experience: just a single offline HTML file on the host, bootstrapped onto the guest via &lt;2,953 bytes of HTML squeezed into a single QR code (plus a return QR code is required for some browser engines). No servers in the middle, just two web browsers speaking WebRTC and JavaScript to each other.</p>

            <p>Please read the caveats below before trying it out! It is incredibly cool that it is even possible, and even somewhat portable between browsers (though Chromium works best), and I have done my best to smooth out the rough edges to make it pleasant to use. The concept underlying the connection procedure is relatively simple, and I have written a chat app on top to demonstrate its usefulness and test aspects like latency (try running /ping).</p>

            <p>More information and downloads at <a href="https://webrtc-over-qr.veritates.love/">https://webrtc-over-qr.veritates.love/</a>.</p>
          </div>
          <details open id="caveats">
            <summary><h2 style="display: inline; cursor: pointer">Caveats</h2></summary>

            <ul>
              <li><p>WebRTC discovery works differently across browser engines. Chromium-based browsers give the nicest experience: we are able to auto-discover guests when they open the page and try to connect. On other engines (like Safari and Firefox), the certificate fingerprint generated by the guest must be sent back to the host via some other method (QR code, copy+paste, instant message, verbal transcription, etc.).</p> <p>Our mode of connection (entirely peer-to-peer) is somewhat unintended, as WebRTC was designed to have a (trusted!) signaling server mediate a connection. Thus there is no uniform experience we can offer, although we can try our best and add workarounds for these situations.</p></li>
              <li><p>Firefox behaves very differently based on the flag <code>media.peerconnection.ice.obfuscate_host_addresses</code> in <code>about:config</code> (which is set to <code>true</code> by default). In particular, it seems to impose a ~5 second timeout as guest. And as host, it will not connect to a Chromium guest? So you might want to set this to <code>false</code> while trying the demo, or use a different browser instead. Note that it is a global setting, so remember to set it back to the default <code>true</code> when you are done.</p></li>
              <li><p>While we produce standards-compliant QR codes, they aren’t exactly usable by existing software: the QR code generated by the host contains a data URI, which most phone apps will not recognize as a link, and even if they do, browsers will not open data URIs from external sources (or in the case of Firefox on iOS, ever at all), so you may have to use a different <a href="https://webrtc-over-qr.veritates.love/scanner">QR code scanner</a> and copy and paste the URL into a browser. And on the flip side, the QR code generated by the guest is 32 bytes of raw binary data, which most scanners will not even display for you, and would not be safe to copy as text. However, this is less of an issue since we can embed a QR scanner here in secure contexts (HTTPS, localhost, and apparently local files too).</p></li>
              <li><p>A lot of nice web APIs understandably do not work in insecure contexts. The goal of bootstrapping a peer-to-peer web chat over QR is not secure, so there is not much we can do about it. This means no access to webcams or microphones, no popup notifications, etc., at least from the guest. But there is still a lot of amazing things that we can do, things that any (web) chat app could have done but didn’t.</p></li>
              <li><p>The demo has no way of reestablishing a connection if it drops (I do not know if it would be technically possible at all without manually passing information between the peers again ... you could at least pre-establish the certificates to use). The demo also does not use STUN or TURN servers, which facilitate connections behind NAT/firewalls, so it may only work between devices on your local network. <!-- This is a lie and you can add stun servers using query parameters like `?stun=stun:stun1.example.com:3478&stun=sun:stun2.example.com:3478`. --></p></li>
            </ul>
          </details>
          <hr/>
          <div id="instructions" style="text-align: left; line-height: 130%">
            <h2>Instructions</h2>

            <p>First, open the provided HTML on the guest device. You can get it as a data URI, which you will have to copy and paste into guest's browser (clicking on it will not work, and a <a href="https://webrtc-over-qr.veritates.love/scanner">QR code scanner</a> will need to give you the text of the QR code: they will not open it as a link either), or you can save the HTML to a file and load it that way, or temporarily host it on a webserver and so on.</p>

            <div id="to_guest"></div>

            <p>Then, if the connection does not automatically establish itself (if your host is not Chromium), you will need to get the certificate fingerprint from the guest. You can copy/paste it or enter it manually, or, if the host is loaded in a secure context, you can use the QR code scanner below by selecting a camera to use. Or you can take a picture of the QR code in another app and upload/paste it here.</p>

            <div id="from_guest"></div>

            <p>The WebRTC connection is not particularly time sensitive, so you should have time to open the site on the guest. However, it can only be attempted once, so if it fails or if you get the fingerprint wrong, you will need to refresh this page <!-- or call `host()` --> and restart the whole procedure again. The HTML/QR code is specific to the connection attempt, you cannot reuse it!</p>

            <p>And as mentioned in <a href="#caveats">Caveats</a>, Firefox has different behavior based on the <code>media.peerconnection.ice.obfuscate_host_addresses</code> in <code>about:config</code>. So you might want to set this to <code>false</code> while trying the demo, or try a different browser instead. Note that it is a global setting, so remember to set it back to the default <code>true</code> when you are done.</p>
          </div>
          <hr/>
          <h2>Logs</h2>
        </div>
      </div>
      <div id="controls">
        <label for="file_upload"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path style="fill:currentColor;stroke:none" d="M16 3a3 3 0 0 0-3 3v7H6a3 3 0 0 0 0 6h7v7a3 3 0 0 0 6 0v-7h7a3 3 0 0 0 0-6h-7V6a3 3 0 0 0-3-3z"/></svg></label>
        <input type="file" id="file_upload" multiple disabled />
        <input id="compose" />
      </div>
    </div>
    <script class="ephemeral">
      (function() {
        var watching = ['/design/', '/app.py'].map(tgt => {
          const ws = new WebSocket('/watch' + tgt);
          ws.onmessage = e => {
            let url = e.data;
            let found = false;
            for (let doc of [document, document.querySelector('iframe#hosted')?.contentDocument]) {
              for (let link of doc?.querySelectorAll("link")||[]) {
                let pathname = URL.parse(link.href, location.href).pathname;
                if (pathname === url) {
                  found = true;
                  link.href = pathname + '?' + Math.random();
                }
              }
            }
            if (!found) {
              watching.forEach(w => w.close());
              setTimeout(() => location.reload(), tgt === '/app.py' ? 5000 : 100);
            }
          };
          return ws;
        });
      })();
    </script>
  </body>
</html>