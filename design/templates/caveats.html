<details open id="caveats">
  <summary><h2 style="display: inline; cursor: pointer">Caveats</h2></summary>

  <ul>
    <li><p>WebRTC discovery works differently across browser engines. Chromium-based browsers give the nicest experience: we are able to auto-discover guests when they open the page and try to connect. On other engines (like Safari and Firefox), the certificate fingerprint generated by the guest must be sent back to the host via some other method (QR code, copy+paste, instant message, verbal transcription, etc.).</p> <p>Our mode of connection (entirely peer-to-peer) is somewhat unintended, as WebRTC was designed to have a (trusted!) signaling server mediate a connection. Thus there is no uniform experience we can offer, although we can try our best and add workarounds for these situations.</p></li>
    <li><p>Firefox behaves very differently based on the flag <code>media.peerconnection.ice.obfuscate_host_addresses</code> in <code>about:config</code> (which is set to <code>true</code> by default). In particular, it seems to impose a ~5 second timeout as guest. And as host, it will not connect to a Chromium guest? So you might want to set this to <code>false</code> while trying the demo, or use a different browser instead. Note that it is a global setting, so remember to set it back to the default <code>true</code> when you are done.</p></li>
    <li><p>While we produce standards-compliant QR codes, they aren’t exactly usable by existing software: the QR code generated by the host contains a data URI, which most phone apps will not recognize as a link, and even if they do, browsers will not open data URIs from external sources (or in the case of Firefox on iOS, ever at all), so you may have to install a 3rd party QR code scanner and copy and paste the URL into a browser. And on the flip side, the QR code generated by the guest is 32 bytes of raw binary data, which most scanners will not even display for you, and would not be safe to copy as text. However, this is less of an issue since we can embed a QR scanner here in secure contexts (HTTPS, localhost, and apparently local files too).</p></li>
    <li><p>A lot of nice web APIs understandably do not work in insecure contexts. The goal of bootstrapping a peer-to-peer web chat over QR is not secure, so there is not much we can do about it. This means no access to webcams or microphones, no popup notifications, etc., at least from the guest. But there is still a lot of amazing things that we can do, things that any (web) chat app could have done but didn’t.</p></li>
    <li><p>The demo has no way of reestablishing a connection if it drops (I do not know if it would be technically possible at all without manually passing information between the peers again ... you could at least pre-establish the certificates to use). The demo also does not use STUN or TURN servers, which facilitate connections behind NAT/firewalls, so it may only work between devices on your local network. <!-- This is a lie and you can add stun servers using query parameters like `?stun=stun:stun1.example.com:3478&stun=sun:stun2.example.com:3478`. --></p></li>
  </ul>
</details>
